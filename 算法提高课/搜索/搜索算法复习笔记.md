# 📚 搜索算法复习笔记合集

## 目录 (Table of Contents)

1. [BFS — Flood Fill（洪水填充）](#1-bfs--flood-fill洪水填充)
2. [BFS — 最短路模型](#2-bfs--最短路模型)
3. [BFS — 多源 BFS](#3-bfs--多源-bfs)
4. [BFS — 最小步数模型（状态空间BFS）](#4-bfs--最小步数模型状态空间bfs)
5. [BFS — 双端队列广搜（0-1 BFS）](#5-bfs--双端队列广搜0-1-bfs)
6. [BFS — 双向广搜](#6-bfs--双向广搜)
7. [BFS — A*（启发式搜索）](#7-bfs--a启发式搜索)
8. [DFS — 连通性模型](#8-dfs--连通性模型)
9. [DFS — 搜索顺序](#9-dfs--搜索顺序)
10. [DFS — 剪枝与优化](#10-dfs--剪枝与优化)
11. [DFS — 迭代加深（IDDFS）](#11-dfs--迭代加深iddfs)
12. [DFS — 双向DFS（Meet in the Middle）](#12-dfs--双向dfsmeet-in-the-middle)
13. [DFS — IDA*](#13-dfs--ida)

---

## 1. BFS — Flood Fill（洪水填充）

### 1.1 算法概述与选型指南
**核心思想**：从某个起点出发，用 BFS/DFS 将所有连通的同类格子染色/标记，统计连通块数量或属性。

**决策表格**：
| 算法/模型 | 适用场景 | 时间复杂度 | 典型例题 |
|---|---|---|---|
| BFS Flood Fill | 网格图连通块计数/染色，$N \le 10^3$ | $O(NM)$ | 1097 池塘计数、1098 城堡问题 |
| DFS Flood Fill | 同上，代码更短，但栈溢出风险 | $O(NM)$ | 1113 红与黑 |
| 带属性统计 | 需判断连通块与外部关系（山峰/山谷） | $O(NM)$ | 1106 山峰和山谷 |

### 1.2 核心模板
**变量定义**：`g[N][N]` 地图，`st[N][N]` 访问标记，`dx/dy` 八方向或四方向偏移。

```cpp
#include <iostream>
#include <queue>
using namespace std;
const int N = 1010;
typedef pair<int, int> PII;
char g[N][N];
bool st[N][N];
int n, m;

void bfs(int sx, int sy) {
    queue<PII> q;
    q.push({sx, sy});
    st[sx][sy] = true;
    while (q.size()) {
        PII t = q.front(); q.pop();
        for (int i = t.first - 1; i <= t.first + 1; i++)
            for (int j = t.second - 1; j <= t.second + 1; j++) {
                if (i < 0 || i >= n || j < 0 || j >= m) continue;
                if (i == t.first && j == t.second) continue;
                if (g[i][j] == '.' || st[i][j]) continue;
                st[i][j] = true;
                q.push({i, j});
            }
    }
}
```

### 1.3 进阶技巧与模型变形
- **位运算符判断墙壁**：在城堡问题中，坐标 $(x,y)$ 的墙壁信息存储在 `g[x][y]` 中，判断 `g[x][y] >> i & 1`。
- **带参 BFS**：在山峰山谷问题中，传入 `has_higher` 和 `has_lower` 引用来统计连通块属性。

### 1.4 ⚠️ 细节与致命坑点
- **标记时机**：必须在入队时标记 `st = true`，否则会导致同一节点重复入队，复杂度退化。
- **数组范围**：处理格点图时，注意 $N$ 和 $M$ 的大小，防止越界。

---

## 2. BFS — 最短路模型

### 2.1 算法概述与选型指南
**核心思想**：无权图（或边权均为 1）的最短路，BFS 第一次搜到目标点即为最短路径。

**决策表格**：
| 算法/模型 | 适用场景 | 时间复杂度 | 典型例题 |
|---|---|---|---|
| 标准 BFS | 边权均为 1 的网格图最短路 | $O(NM)$ | 1076 迷宫问题 |
| 一维状态 BFS | 状态转移规则单一且离散 | $O(N)$ | 1100 抓住那头牛 |

### 2.2 核心模板
**变量定义**：`pre[N][N]` 记录前驱坐标以便回溯路径。

```cpp
void bfs(int sx, int sy) {
    queue<PII> q;
    q.push({sx, sy});
    st[sx][sy] = true;
    while (q.size()) {
        PII t = q.front(); q.pop();
        for (int i = 0; i < 4; i++) {
            int nx = t.first + dx[i], ny = t.second + dy[i];
            if (nx < 0 || nx >= n || ny < 0 || ny >= n || g[nx][ny] || st[nx][ny]) continue;
            st[nx][ny] = true;
            pre[nx][ny] = t; // 记录路径
            q.push({nx, ny});
        }
    }
}
```

### 2.3 进阶技巧与模型变形
- **反向搜索记录路径**：从终点向起点搜，`pre` 存的就是正向的下一个点，直接输出即可。
- **自定义移动规则**：马走日等特殊距离移动。

### 2.4 ⚠️ 细节与致命坑点
- **初始化**：`dist` 或 `st` 的清空，多组数据时尤其注意。
- **边界判断**：一维搜索时注意范围不要溢出数组。

---

## 3. BFS — 多源 BFS

### 3.1 算法概述与选型指南
**核心思想**：求多个起点到其他格子的最短距离。将所有起点同时加入队列。

**决策表格**：
| 算法/模型 | 适用场景 | 时间复杂度 | 典型例题 |
|---|---|---|---|
| 多源 BFS | 多个源点，求全局最短距离分布 | $O(NM)$ | 173 矩阵距离 |

### 3.2 核心模板
```cpp
void bfs() {
    queue<PII> q;
    for (int i = 1; i <= n; i++)
        for (int j = 1; j <= m; j++)
            if (g[i][j] == '1') { st[i][j] = true; q.push({i, j}); }
    while (q.size()) {
        PII t = q.front(); q.pop();
        for (int i = 0; i < 4; i++) {
            int nx = t.first + dx[i], ny = t.second + dy[i];
            if (nx < 1 || nx > n || ny < 1 || ny > m || st[nx][ny]) continue;
            st[nx][ny] = true;
            dist[nx][ny] = dist[t.first][t.second] + 1;
            q.push({nx, ny});
        }
    }
}
```

### 3.3 进阶技巧与模型变形
- **等价转换**：建立一个虚拟源点，连向所有真实起点，边权为 0。

### 3.4 ⚠️ 细节与致命坑点
- **读入格式**：矩阵中字符和数字的读入，推荐 `scanf("%s", g[i])`。

---

## 4. BFS — 最小步数模型（状态空间BFS）

### 4.1 算法概述与选型指南
**核心思想**：将问题的每个状态看作图中的点，求最少操作次数。

**决策表格**：
| 算法/模型 | 适用场景 | 时间复杂度 | 典型例题 |
|---|---|---|---|
| 状态 BFS | 状态总数较小（如 8!），操作等权 | $O(\text{状态数})$ | 1107 魔板 |

### 4.2 核心模板
**变量定义**：`unordered_map<string, string> res` 记录状态到操作序列的映射。

```cpp
string change(string str, int j) {
    int dx[3][8] = {{7, 6, 5, 4, 3, 2, 1, 0}, {3, 0, 1, 2, 5, 6, 7, 4}, {0, 6, 1, 3, 4, 2, 5, 7}};
    string tmp = "";
    for (int i = 0; i < 8; i++) tmp += str[dx[j][i]];
    return tmp;
}
```

### 4.3 进阶技巧与模型变形
- **哈希映射**：用 `unordered_map` 或康托展开映射排列到整数。
- **序列化**：网格状态转字符串。

### 4.4 ⚠️ 细节与致命坑点
- **起始状态检查**：`start == target` 时直接输出 0。

---

## 5. BFS — 双端队列广搜（0-1 BFS）

### 5.1 算法概述与选型指南
**核心思想**：图中边权只有 0 和 1 两种。使用 `deque`。

**决策表格**：
| 算法/模型 | 适用场景 | 时间复杂度 | 典型例题 |
|---|---|---|---|
| 0-1 BFS | 网格图中存在"不花代价"和"花 1 代价"的转移 | $O(NM)$ | 175 电路维修 |

### 5.2 核心模板
```cpp
while (q.size()) {
    PII t = q.front(); q.pop_front();
    if (st[t.first][t.second]) continue;
    st[t.first][t.second] = true;
    // ...
    if (w) q.push_back({a, b});
    else q.push_front({a, b});
}
```

### 5.3 进阶技巧与模型变形
- **节点定义**：对于格点路径问题，注意格点坐标和格子坐标的关系。

---

## 6. BFS — 双向广搜

### 6.1 算法概述与选型指南
**核心思想**：从起点和终点同时搜。每次扩展层数较小的一端。

**决策表格**：
| 算法/模型 | 适用场景 | 时间复杂度 | 典型例题 |
|---|---|---|---|
| 双向 BFS | 起始状态和结束状态均明确，分支庞大 | $O(b^{d/2})$ | 190 字串变换 |

### 6.2 核心模板
```cpp
int extend(queue<string> &q, unordered_map<string, int> &da, unordered_map<string, int> &db, string a[], string b[]) {
    int d = da[q.front()];
    while (q.size() && da[q.front()] == d) {
        // 扩展逻辑 ...
        if (db.count(next)) return da[curr] + 1 + db[next];
    }
}
```

---

## 7. BFS — A*（启发式搜索）

### 7.1 算法概述与选型指南
**核心思想**：$f(n) = g(n) + h(n)$。$g(n)$ 是当前代价，$h(n)$ 是估计剩余代价。

**决策表格**：
| 算法/模型 | 适用场景 | 时间复杂度 | 典型例题 |
|---|---|---|---|
| A* | 第 K 短路，状态空间搜索，估价值不大于实际值 | 启发性强则快 | 178 第K短路 |

### 7.2 核心模板
- **估价函数**：`dist` 反向图中从终点到各点的距离。
- **第 K 次弹出**：当终点第 K 次从堆中弹出，即为第 K 短路。

---

## 8. DFS — 连通性模型

### 8.1 算法概述与选型指南
**核心思想**：深度优先遍历图。

**决策表格**：
| 算法/模型 | 适用场景 | 时间复杂度 | 典型例题 |
|---|---|---|---|
| DFS | 连通性判断，连通块大小统计 | $O(NM)$ | 1112 迷宫 |

---

## 9. DFS — 搜索顺序

### 9.1 算法概述与选型指南
**核心思想**：搜索顺序对效率影响巨大。

**决策表格**：
| 算法/模型 | 适用场景 | 时间复杂度 | 典型例题 |
|---|---|---|---|
| 分组 DFS | 元素必须被分入不同的、满足某种性质的组里 | 指数级 | 1118 分成互质组 |

---

## 10. DFS — 剪枝与优化

### 10.1 算法概述与选型指南
**五大剪枝策略**：
1. **优化搜索顺序**（先选分支少的）。
2. **排除等效决策**（组合数，防止冗余）。
3. **可行性剪枝**（提前出局）。
4. **最优性剪枝**（半路已经比答案慢）。
5. **记忆化**（相同状态不重算）。

---

## 11. DFS — 迭代加深（IDDFS）

### 11.1 算法概述与选型指南
**核心思想**：模拟 BFS，限定深度的 DFS。

**决策表格**：
| 算法/模型 | 适用场景 | 时间复杂度 | 典型例题 |
|---|---|---|---|
| 迭代加深 | 搜索树深不见底，但答案在很浅的地方 | $O(b^d)$ | 170 加成序列 |

---

## 12. DFS — 双向DFS（Meet in the Middle）

### 12.1 算法概述与选型指南
**核心思想**：折半搜索。

| 算法/模型 | 适用场景 | 时间复杂度 | 典型例题 |
|---|---|---|---|
| 双向 DFS | $N$ 约为 40，子集枚举或背包类问题 | $O(2^{N/2})$ | 171 送礼物 |

---

## 13. DFS — IDA*

### 13.1 算法概述与选型指南
**核心思想**：迭代加深 DFS + 估价剪枝。

| 算法/模型 | 适用场景 | 时间复杂度 | 典型例题 |
|---|---|---|---|
| IDA* | 状态空间庞大，深度较浅，且有估值函数 | 启发取决于 $h(n)$ | 181 回转游戏 |

### 13.2 核心模板
```cpp
bool dfs(int depth, int max_depth) {
    if (depth + f() > max_depth) return false;
    if (f() == 0) return true;
    // ...
}
```

### 13.4 ⚠️ 细节与致命坑点
- **估值函数 $h(n)$**：必须保证不多于实际步数。
