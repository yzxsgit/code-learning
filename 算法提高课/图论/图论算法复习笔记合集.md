# 📚 图论算法复习笔记合集

## 目录

1. [单源最短路](#1-单源最短路)
2. [全源最短路 (Floyd)](#2-全源最短路-floyd)
3. [最小生成树](#3-最小生成树)
4. [拓扑排序](#4-拓扑排序)
5. [强连通分量 (Tarjan)](#5-强连通分量-tarjan)
6. [无向图双连通分量](#6-无向图双连通分量)
7. [最近公共祖先 (LCA)](#7-最近公共祖先-lca)
8. [二分图](#8-二分图)
9. [差分约束](#9-差分约束)
10. [欧拉路径与欧拉回路](#10-欧拉路径与欧拉回路)
11. [负环判定](#11-负环判定)

---

## 1. 单源最短路

### 1.1 算法概述与选型指南

**核心思想**：求解从单一源点到图中所有其他顶点的最短路径。

| 算法 | 适用场景 | 时间复杂度 | 关键限制 |
|:---:|:---:|:---:|:---:|
| **Dijkstra (堆优化)** | 非负权边、$N \le 10^5$ | $O(M \log N)$ | **不可处理负权边** |
| **Dijkstra (朴素)** | 稠密图、$N \le 500$ | $O(N^2)$ | 邻接矩阵存储 |
| **SPFA** | 有负权边、判负环 | 最坏 $O(NM)$，平均较快 | 可被特殊数据卡掉 |
| **Bellman-Ford** | 有负权边、限制边数 | $O(NM)$ | 最短路经过 $\le k$ 条边 |

**决策流程**：
- 无负权 $\rightarrow$ **堆优化 Dijkstra**（首选）
- 有负权需判环 $\rightarrow$ **SPFA**
- 有负权且限制边数 $\rightarrow$ **Bellman-Ford**

### 1.2 核心模板

**变量说明**：
- `dist[i]`：源点到顶点 $i$ 的当前最短距离
- `st[i]`：Dijkstra中标记是否已确定最短路；SPFA中标记是否在队列中

**堆优化 Dijkstra**（最常用）：
```cpp
const int N = 1e5 + 10, M = 2e5 + 10;
int h[N], e[M], ne[M], w[M], idx;
int dist[N];
bool st[N];

void dijkstra(int start) {
    memset(dist, 0x3f, sizeof dist);
    dist[start] = 0;
    
    priority_queue<PII, vector<PII>, greater<PII>> heap;
    heap.push({0, start});
    
    while (heap.size()) {
        auto [d, u] = heap.top();
        heap.pop();
        
        if (st[u]) continue;  // 已经确定最短路
        st[u] = true;
        
        for (int i = h[u]; ~i; i = ne[i]) {
            int v = e[i];
            if (dist[v] > dist[u] + w[i]) {
                dist[v] = dist[u] + w[i];
                heap.push({dist[v], v});
            }
        }
    }
}
```

**SPFA 模板**：
```cpp
void spfa(int start) {
    memset(dist, 0x3f, sizeof dist);
    dist[start] = 0;
    
    queue<int> q;
    q.push(start);
    st[start] = true;
    
    while (q.size()) {
        int u = q.front();
        q.pop();
        st[u] = false;  // 出队标记
        
        for (int i = h[u]; ~i; i = ne[i]) {
            int v = e[i];
            if (dist[v] > dist[u] + w[i]) {
                dist[v] = dist[u] + w[i];
                if (!st[v]) {  // 不在队列才入队
                    q.push(v);
                    st[v] = true;
                }
            }
        }
    }
}
```

### 1.3 进阶技巧与模型变形

- **虚拟源点**：多源最短路时，建立超级源点 $0$，向所有真实源点连权值为 $0$ 的边
- **分层图**：有状态限制时（如免费通行 $k$ 次），扩展状态为 $(u, k_{\text{used}})$
- **最短路计数**：`cnt[v] = (dist[v] == dist[u] + w) ? cnt[v] + cnt[u] : cnt[v]`
- **次短路**：维护 `dist1[]`（最短路）和 `dist2[]`（次短路）两个数组
- **双端队列 BFS (0-1 BFS)**：边权只有 $0$ 和 $1$ 时，用 `deque` 替代堆，$O(N)$
- **边权转点权**：将边拆成点，或将点权通过拆点/超级源点技巧处理

### 1.4 ⚠️ 细节与致命坑点

- **初始化**：`memset(dist, 0x3f, sizeof dist)` 设置正无穷为 $0x3f3f3f3f$（约 $1e9$）
- **判不可达**：`if (dist[T] == 0x3f3f3f3f)` 表示无法到达
- **重边处理**：建图时取 `min(g[u][v], w)`，邻接表直接加边即可（算法自动选最优）
- **自环**：通常不影响最短路，但需根据题意判断
- **long long**：边权和可能溢出 `int` 时（如 $N \times W > 2e9$），改用 `long long`
- **SPFA 判重**：入队标记 `st[]` 必须在**出队时清除**，否则同一节点无法再次更新

---

## 2. 全源最短路 (Floyd)

### 2.1 算法概述与选型指南

**核心思想**：动态规划，通过中间点集合逐步扩展，求解任意两点间最短路。

| 算法 | 适用场景 | 时间复杂度 | 关键特性 |
|:---:|:---:|:---:|:---:|
| **Floyd** | 多源最短路、$N \le 500$ | $O(N^3)$ | 可处理负权、可传递闭包 |
| **N 次 Dijkstra** | 无负权、$N \le 10^4$ | $O(NM \log N)$ | 稀疏图更优 |

### 2.2 核心模板

**变量说明**：
- `d[i][j]`：顶点 $i$ 到 $j$ 的最短距离

```cpp
const int N = 510, INF = 0x3f3f3f3f;
int d[N][N];
int n, m;

void floyd() {
    // 初始化：对角线为0，其余为INF
    for (int i = 1; i <= n; i++)
        for (int j = 1; j <= n; j++)
            d[i][j] = (i == j) ? 0 : INF;
    
    // 读入边...
    
    // 核心：k必须放在最外层
    for (int k = 1; k <= n; k++)
        for (int i = 1; i <= n; i++)
            for (int j = 1; j <= n; j++)
                d[i][j] = min(d[i][j], d[i][k] + d[k][j]);
}
```

**路径记录**：
```cpp
int pos[N][N];  // 记录i到j经过的中间点

// 初始化时
pos[i][j] = 0;

// 更新时
if (d[i][k] + d[k][j] < d[i][j]) {
    d[i][j] = d[i][k] + d[k][j];
    pos[i][j] = k;  // 记录中间点
}
```

### 2.3 进阶技巧与模型变形

- **最小环**：在 Floyd 过程中，当 $k$ 作为中间点更新前，检查 $d[i][j] + g[j][k] + g[k][i]$（$i,j < k$）
- **传递闭包**：`d[i][j] |= d[i][k] & d[k][j]`，用于可达性判断
- **倍增 Floyd**：结合快速幂求解恰好经过 $k$ 条边的最短路（矩阵乘法意义下的幂）
- **分数规划**：结合二分判断是否存在平均权值小于 $mid$ 的环

### 2.4 ⚠️ 细节与致命坑点

- **k 的顺序**：$k$ 必须放在**最外层循环**，否则状态不正确
- **重边取 min**：`g[a][b] = min(g[a][b], c)`
- **自环忽略**：初始化对角线为 $0$，忽略输入的自环
- **负环检测**：若 `d[i][i] < 0`，说明存在从 $i$ 出发的负环
- **空间限制**：$N > 500$ 时 $O(N^2)$ 空间可能超限，需用滚动数组或多次Dijkstra

---

## 3. 最小生成树

### 3.1 算法概述与选型指南

**核心思想**：选择 $N-1$ 条边连接 $N$ 个顶点，使总权值最小且无环。

| 算法 | 适用场景 | 时间复杂度 | 关键特性 |
|:---:|:---:|:---:|:---:|
| **Kruskal** | 稀疏图、$M \le 10^5$ | $O(M \log M)$ | 边排序 + 并查集 |
| **Prim (堆优化)** | 稠密图、$N \le 10^5$ | $O(M \log N)$ | 类似 Dijkstra |
| **Prim (朴素)** | 稠密图、$N \le 500$ | $O(N^2)$ | 邻接矩阵 |

### 3.2 核心模板

**Kruskal（最常用）**：
```cpp
const int N = 1e5 + 10, M = 2e5 + 10;

struct Edge {
    int a, b, w;
    bool operator<(const Edge& t) const { return w < t.w; }
} e[M];

int p[N];  // 并查集
int find(int x) {
    if (p[x] != x) p[x] = find(p[x]);
    return p[x];
}

long long kruskal(int n, int m) {
    for (int i = 1; i <= n; i++) p[i] = i;
    sort(e, e + m);
    
    long long res = 0;
    int cnt = 0;  // 已选边数
    
    for (int i = 0; i < m; i++) {
        int a = find(e[i].a), b = find(e[i].b);
        if (a != b) {
            p[a] = b;
            res += e[i].w;
            cnt++;
        }
    }
    
    return (cnt < n - 1) ? -1 : res;  // -1表示图不连通
}
```

**Prim (朴素版，邻接矩阵)**：
```cpp
int g[N][N], dist[N];
bool st[N];

int prim(int n) {
    memset(dist, 0x3f, sizeof dist);
    dist[1] = 0;
    
    int res = 0;
    for (int i = 0; i < n; i++) {
        int t = -1;
        for (int j = 1; j <= n; j++)
            if (!st[j] && (t == -1 || dist[j] < dist[t]))
                t = j;
        
        if (dist[t] == 0x3f3f3f3f) return -1;  // 图不连通
        
        res += dist[t];
        st[t] = true;
        
        for (int j = 1; j <= n; j++)
            dist[j] = min(dist[j], g[t][j]);
    }
    return res;
}
```

### 3.3 进阶技巧与模型变形

- **虚拟源点**：处理 "建立基站/发电站有成本" 问题，建立超级源点 $0$，向各点连边表示建站成本
- **次小生成树**：先求 MST，对每条非树边 $(u,v,w)$，用 LCA 求 $u$ 到 $v$ 路径上的最大边权 $maxw$，候选答案为 $sum - maxw + w$
- **严格次小生成树**：需同时维护最大和次大边权，当 $w = maxw$ 时用次大边替换
- **最大生成树**：边权取负或排序改降序
- **最小瓶颈生成树**：MST 一定是最小瓶颈生成树
- **最小树形图 (朱刘算法)**：有向图的最小生成树

### 3.4 ⚠️ 细节与致命坑点

- **重边处理**：邻接矩阵取 `min`，Kruskal 排序后自然处理
- **自环忽略**：Kruskal 中自环两端点相同会被并查集过滤
- **图不连通判断**：Kruskal 统计 `cnt < n-1`；Prim 判断 `dist[t] == INF`
- **long long**：总权值可能溢出 `int`
- **边数组大小**：无向图边数要开 $2M$

---

## 4. 拓扑排序

### 4.1 算法概述与选型指南

**核心思想**：将 DAG（有向无环图）的顶点排成线性序列，使得对所有边 $(u,v)$，$u$ 在 $v$ 前面。

| 算法 | 适用场景 | 时间复杂度 | 关键特性 |
|:---:|:---:|:---:|:---:|
| **Kahn (BFS)** | 标准拓扑排序 | $O(N + M)$ | 入度为0的队列 |
| **DFS 版** | 需要逆序输出 | $O(N + M)$ | 后序遍历压栈 |

### 4.2 核心模板

**Kahn 算法**：
```cpp
const int N = 1e5 + 10;
vector<int> adj[N];
int din[N];  // 入度
vector<int> res;  // 拓扑序结果

bool topsort(int n) {
    queue<int> q;
    for (int i = 1; i <= n; i++)
        if (din[i] == 0) q.push(i);
    
    while (q.size()) {
        int u = q.front();
        q.pop();
        res.push_back(u);
        
        for (int v : adj[u]) {
            din[v]--;
            if (din[v] == 0) q.push(v);
        }
    }
    
    return res.size() == n;  // 存在环时size < n
}
```

### 4.3 进阶技巧与模型变形

- **判断环**：拓扑排序后 `res.size() < n` 说明有环
- **字典序最小/最大拓扑序**：将队列换成优先队列（小根堆/大根堆）
- **关键路径 (DP)**：按拓扑序进行 DP，求最长路径
- **可达性统计**：按逆拓扑序，用 `bitset` 进行集合或运算

### 4.4 ⚠️ 细节与致命坑点

- **入度数组**：必须复制原图入度，排序过程中会修改
- **多解情况**：普通队列输出任意拓扑序；优先队列输出字典序
- **重边**：重边会导致入度计算错误，需去重或特殊处理
- **判环时机**：必须等排序完成后通过 `res.size()` 判断，而非排序过程中

---

## 5. 强连通分量 (Tarjan)

### 5.1 算法概述与选型指南

**核心思想**：通过 DFS 求每个点的 `dfn`（访问序）和 `low`（能到达的最小 `dfn`），`low == dfn` 时形成一个 SCC。

| 算法 | 适用场景 | 时间复杂度 | 关键特性 |
|:---:|:---:|:---:|:---:|
| **Tarjan** | 求 SCC、缩点 | $O(N + M)$ | 一遍 DFS |
| **Kosaraju** | 求 SCC | $O(N + M)$ | 两遍 DFS |

### 5.2 核心模板

**变量说明**：
- `dfn[u]`：$u$ 的 DFS 序（时间戳）
- `low[u]`：$u$ 能追溯到的最小 `dfn`
- `scc_id[u]`：$u$ 所属的 SCC 编号
- `stk`：维护当前 DFS 路径上的点

```cpp
const int N = 1e5 + 10;
vector<int> g[N];
int dfn[N], low[N], timer = 0;
int scc_id[N], scc_size[N], scc_cnt = 0;
stack<int> stk;
bool in_stk[N];

void tarjan(int u) {
    dfn[u] = low[u] = ++timer;
    stk.push(u);
    in_stk[u] = true;
    
    for (int v : g[u]) {
        if (!dfn[v]) {
            tarjan(v);
            low[u] = min(low[u], low[v]);
        } else if (in_stk[v]) {
            // 回边，更新low
            low[u] = min(low[u], dfn[v]);
        }
    }
    
    // u是SCC的根
    if (low[u] == dfn[u]) {
        scc_cnt++;
        int v;
        do {
            v = stk.top();
            stk.pop();
            in_stk[v] = false;
            scc_id[v] = scc_cnt;
            scc_size[scc_cnt]++;
        } while (v != u);
    }
}
```

**缩点建 DAG**：
```cpp
// 遍历原图所有边
for (int u = 1; u <= n; u++)
    for (int v : g[u])
        if (scc_id[u] != scc_id[v])
            dag[scc_id[u]].push_back(scc_id[v]);
```

### 5.3 进阶技巧与模型变形

- **缩点**：将 SCC 缩成一个点，原图变为 DAG
- **缩点后入度/出度分析**：
  - 入度为 $0$ 的 SCC 需要接收信号（最少发放点）
  - 出度为 $0$ 的 SCC 无法传递信号（需要连边使其连通）
- **最大半连通子图**：缩点后求最长链
- **2-SAT**：利用 SCC 判定布尔方程组的可行性

### 5.4 ⚠️ 细节与致命坑点

- **栈的判断**：`in_stk[v]` 必须判断，只更新栈中的回边（横叉边不更新）
- **数组初始化**：`timer` 从 $1$ 开始，`dfn` 为 $0$ 表示未访问
- **重边**：不影响正确性
- **自环**：会形成单独的 SCC
- **栈清空**：形成 SCC 后必须清空栈中对应点，标记 `in_stk = false`

---

## 6. 无向图双连通分量

### 6.1 算法概述与选型指南

**核心思想**：
- **桥（割边）**：删除后图不连通的边
- **割点**：删除后图不连通的点
- **边双连通分量 (eDCC)**：不含桥的最大子图
- **点双连通分量 (vDCC)**：不含割点的最大子图

| 概念 | 判定条件 | 应用场景 |
|:---:|:---:|:---:|
| **桥** | `dfn[u] < low[v]` | 关键道路 |
| **割点** | `dfn[u] <= low[v]`（非根）或子树数 $> 1$（根）| 关键节点 |

### 6.2 核心模板

**边双连通分量 (eDCC)**：
```cpp
const int N = 5e3 + 10, M = 2e4 + 10;
int h[N], e[M], ne[M], idx = 0;
void add(int a, int b) {
    e[idx] = b, ne[idx] = h[a], h[a] = idx++;
}

int dfn[N], low[N], timer = 0;
int ebcc_id[N], ebcc_cnt = 0;
bool is_bridge[M];
stack<int> stk;

void tarjan(int u, int from) {  // from为来的边的编号
    dfn[u] = low[u] = ++timer;
    stk.push(u);
    
    for (int i = h[u]; ~i; i = ne[i]) {
        int v = e[i];
        if (i == (from ^ 1)) continue;  // 忽略反向边（成对存边）
        
        if (!dfn[v]) {
            tarjan(v, i);
            low[u] = min(low[u], low[v]);
            if (dfn[u] < low[v])  // 发现桥
                is_bridge[i] = is_bridge[i ^ 1] = true;
        } else {
            low[u] = min(low[u], dfn[v]);
        }
    }
    
    if (dfn[u] == low[u]) {  // eDCC的根
        ebcc_cnt++;
        int v;
        do {
            v = stk.top();
            stk.pop();
            ebcc_id[v] = ebcc_cnt;
        } while (v != u);
    }
}
```

### 6.3 进阶技巧与模型变形

- **桥树**：将每个 eDCC 缩点，桥成为新树的边，问题转化为树上问题
- **加边成边双连通**：统计桥树中度为 $1$ 的点数 $leaf$，答案为 $(leaf + 1) / 2$
- **仙人掌图**：每条边最多在一个简单环中的图，可用双连通分量处理

### 6.4 ⚠️ 细节与致命坑点

- **成对存边**：边的编号 $0,1$ 是一对，$2,3$ 是一对，用 `i ^ 1` 找反向边
- **from 参数**：必须传递边的编号而非点，否则重边会被误判为桥
- **重边**：两点间有多条边时，这些边都不是桥
- **自环**：自环会形成 eDCC，但桥的判断要注意

---

## 7. 最近公共祖先 (LCA)

### 7.1 算法概述与选型指南

**核心思想**：通过二进制跳跃预处理，$O(N \log N)$ 预处理，$O(\log N)$ 单次查询。

| 算法 | 预处理 | 单次查询 | 适用场景 |
|:---:|:---:|:---:|:---:|
| **倍增法** | $O(N \log N)$ | $O(\log N)$ | 最常用 |
| **Tarjan (离线)** | $O(N \alpha(N))$ | $O(1)$ 均摊 | 多查询、离线 |
| **树链剖分** | $O(N)$ | $O(\log N)$ | 路径修改/查询 |
| **欧拉序 + RMQ** | $O(N \log N)$ | $O(1)$ | 查询极多 |

### 7.2 核心模板

**倍增法**：
```cpp
const int N = 4e4 + 10, LOG = 16;
vector<int> g[N];
int fa[N][LOG], depth[N];

void bfs(int root) {
    memset(depth, 0x3f, sizeof depth);
    depth[0] = 0;  // 哨兵
    depth[root] = 1;
    
    queue<int> q;
    q.push(root);
    
    while (q.size()) {
        int u = q.front();
        q.pop();
        
        for (int v : g[u]) {
            if (depth[v] > depth[u] + 1) {
                depth[v] = depth[u] + 1;
                q.push(v);
                
                fa[v][0] = u;  // 2^0 = 1级祖先
                for (int k = 1; k < LOG; k++)
                    fa[v][k] = fa[fa[v][k-1]][k-1];
            }
        }
    }
}

int lca(int a, int b) {
    if (depth[a] < depth[b]) swap(a, b);
    
    // 将a跳到与b同一深度
    for (int k = LOG - 1; k >= 0; k--)
        if (depth[fa[a][k]] >= depth[b])
            a = fa[a][k];
    
    if (a == b) return a;
    
    // 同时向上跳
    for (int k = LOG - 1; k >= 0; k--)
        if (fa[a][k] != fa[b][k]) {
            a = fa[a][k];
            b = fa[b][k];
        }
    
    return fa[a][0];
}
```

**维护路径最大/最小值（用于次小生成树）**：
```cpp
int d1[N][LOG], d2[N][LOG];  // 最大、次大边权

// BFS时初始化
for (int k = 1; k < LOG; k++) {
    int anc = fa[v][k-1];
    fa[v][k] = fa[anc][k-1];
    
    // 合并四个候选值
    int dist[4] = {d1[v][k-1], d2[v][k-1], d1[anc][k-1], d2[anc][k-1]};
    d1[v][k] = d2[v][k] = -INF;
    for (int d : dist) {
        if (d > d1[v][k]) d2[v][k] = d1[v][k], d1[v][k] = d;
        else if (d != d1[v][k] && d > d2[v][k]) d2[v][k] = d;
    }
}
```

### 7.3 进阶技巧与模型变形

- **树上差分**：统计路径覆盖次数，点差分 `cnt[u]++, cnt[v]++, cnt[lca] -= 2`
- **路径边权和**：预处理前缀和 `dist[u]`，路径和为 `dist[u] + dist[v] - 2*dist[lca]`
- **结合其他数据结构**：树链剖分 + 线段树处理路径修改查询
- **虚树**：只保留关键点和其 LCA，压缩树规模

### 7.4 ⚠️ 细节与致命坑点

- **深度初始化**：`depth[0] = 0` 作为哨兵，确保跳到根的父亲时停止
- **LOG 取值**：`LOG = log2(N) + 1`，例如 $N=10^5$ 时 $LOG=17$
- **先对齐深度**：必须先将较深节点跳到同一深度
- **最后返回 `fa[a][0]`**：不是返回 $a$，而是其父节点
- **多组数据**：注意清空 `fa` 和 `depth` 数组

---

## 8. 二分图

### 8.1 算法概述与选型指南

**核心思想**：顶点可分为两个集合，集合内部无边。

| 问题 | 算法 | 时间复杂度 | 关键特性 |
|:---:|:---:|:---:|:---:|
| **判定** | 染色法 (BFS/DFS) | $O(N + M)$ | 无奇环 |
| **最大匹配** | 匈牙利算法 | $O(NM)$ | 增广路 |
| **最大权匹配** | KM 算法 | $O(N^3)$ | 带权匹配 |

### 8.2 核心模板

**染色法判定**：
```cpp
const int N = 2e4 + 10;
vector<pair<int,int>> adj[N];  // (邻居, 边权)
int color[N];

bool dfs(int u, int c, int limit) {
    color[u] = c;
    for (auto [v, w] : adj[u]) {
        if (w <= limit) continue;  // 只考虑权值>limit的边
        if (color[v]) {
            if (color[v] == c) return false;
        } else if (!dfs(v, 3 - c, limit)) {
            return false;
        }
    }
    return true;
}

bool check(int limit) {
    memset(color, 0, sizeof color);
    for (int i = 1; i <= n; i++)
        if (!color[i] && !dfs(i, 1, limit))
            return false;
    return true;
}
```

**匈牙利算法（最大匹配）**：
```cpp
const int N = 510, M = 1e5 + 10;
bool g[N][N], st[N];
int match[N];  // match[j] = i 表示j匹配了i

bool find(int x) {
    for (int j = 1; j <= m; j++) {
        if (!st[j] && g[x][j]) {
            st[j] = true;  // 临时锁定
            if (match[j] == 0 || find(match[j])) {
                match[j] = x;
                return true;
            }
        }
    }
    return false;
}

int hungarian(int n) {
    int res = 0;
    for (int i = 1; i <= n; i++) {
        memset(st, false, sizeof st);
        if (find(i)) res++;
    }
    return res;
}
```

### 8.3 进阶技巧与模型变形

- **最大独立集**：$N - $ 最大匹配数（König 定理）
- **最小点覆盖**：等于最大匹配数
- **最小路径覆盖**（DAG）：$N - $ 拆点后最大匹配
- **最大团**：补图的最大独立集
- **二分图带权匹配**：KM 算法或费用流
- **结合二分答案**：如 "关押罪犯" 问题，二分最大冲突值判定可行性

### 8.4 ⚠️ 细节与致命坑点

- **染色初始化**：每组数据必须 `memset(color, 0, sizeof color)`
- **匈牙利 `st` 数组**：每次 `find` 前必须清空，表示本轮已访问
- **匹配数组初始化**：`match` 初始化为 $0$ 或 $-1$
- **建图方向**：匈牙利算法中只需从左部向右部连边
- **最大匹配数**：最多为 $\min(|L|, |R|)$

---

## 9. 差分约束

### 9.1 算法概述与选型指南

**核心思想**：将约束 $x_i - x_j \le c$ 转化为边 $j \xrightarrow{c} i$，求最短路/最长路。

| 约束形式 | 转化边 | 求解方式 |
|:---:|:---:|:---:|
| $x_i - x_j \le c$ | $j \to i$，权 $c$ | 求最短路 |
| $x_i - x_j \ge c$ | $j \to i$，权 $c$ | 求最长路 |
| $x_i = x_j$ | 双向边权 $0$ | 最短路/最长路均可 |
| $x_i - x_j < c$ | 转化为 $\le c-1$ | 整数时适用 |

### 9.2 核心模板

**求最短路（约束为 $x_i - x_j \le c$）**：
```cpp
const int N = 5e4 + 10;
vector<pair<int,int>> g[N];  // (目标点, 权值)
int dist[N];
bool st[N];

bool spfa(int n) {
    // 超级源点 0 向所有点连边权 0 的边
    for (int i = 1; i <= n; i++) {
        g[0].push_back({i, 0});
    }
    
    memset(dist, 0x3f, sizeof dist);
    dist[0] = 0;
    
    queue<int> q;
    q.push(0);
    st[0] = true;
    
    vector<int> cnt(n + 1);  // 判负环
    
    while (q.size()) {
        int u = q.front();
        q.pop();
        st[u] = false;
        
        for (auto [v, w] : g[u]) {
            if (dist[v] > dist[u] + w) {
                dist[v] = dist[u] + w;
                cnt[v] = cnt[u] + 1;
                if (cnt[v] > n) return false;  // 存在负环，无解
                if (!st[v]) {
                    q.push(v);
                    st[v] = true;
                }
            }
        }
    }
    return true;
}
```

**常见约束转化**：
```cpp
// x_a - x_b >= c  -->  x_b - x_a <= -c  -->  add(a, b, -c)
// x_a - x_b <= c  -->  add(b, a, c)
// x_a == x_b      -->  add(a, b, 0), add(b, a, 0)
// x_a - x_b > c   -->  x_a - x_b >= c+1  -->  add(a, b, -(c+1))
```

### 9.3 进阶技巧与模型变形

- **区间约束**：$S_r - S_{l-1} \ge c$ 形式的前缀和约束
- **区间选点**：转化为前缀和的上下界约束
- **至少/至多**："至少"转最长路，"至多"转最短路
- **求最大/最小值**：
  - 求 $x_i$ 最大值 $\rightarrow$ 最短路（找上界）
  - 求 $x_i$ 最小值 $\rightarrow$ 最长路（找下界）
- **叠加约束**：多个约束同时存在，全部建边

### 9.4 ⚠️ 细节与致命坑点

- **超级源点**：必须添加超级源点 $0$，否则图可能不连通
- **无解判断**：SPFA 判负环（最短路）或正环（最长路）
- **初始化方向**：
  - 最短路：`dist` 初始化为 $INF$
  - 最长路：`dist` 初始化为 $-INF$
- **差一错误**：区间 $[l, r]$ 对应前缀和 $S_r - S_{l-1}$
- **long long**：答案可能很大，用 `long long`

---

## 10. 欧拉路径与欧拉回路

### 10.1 算法概述与选型指南

**核心思想**：经过图中每条边恰好一次的路径。

| 类型 | 存在条件 | 起点/终点 |
|:---:|:---:|:---:|
| **无向图欧拉回路** | 所有点度数为偶数 | 任意点 |
| **无向图欧拉路径** | 恰好两个点度数为奇数 | 奇度点 |
| **有向图欧拉回路** | 所有点入度=出度 | 任意点 |
| **有向图欧拉路径** | 一个点出度=入度+1，一个点入度=出度+1，其余相等 | 出度大者起点 |

### 10.2 核心模板

**Hierholzer 算法**：
```cpp
const int N = 1e5 + 10, M = 2e5 + 10;
vector<pair<int,int>> adj[N];  // (目标点, 边编号)
int din[N], dout[N];
int cur[N];  // 当前弧优化
bool used[M];
vector<int> path;

void dfs(int u) {
    for (int &i = cur[u]; i < adj[u].size(); ) {
        auto [v, id] = adj[u][i];
        i++;  // 关键：先移动指针，避免死循环
        
        if (used[abs(id)]) continue;
        used[abs(id)] = true;
        
        dfs(v);
        path.push_back(id);  // 后序加入
    }
}

// 主函数中
int start = 1;
for (int i = 1; i <= n; i++) {
    if (dout[i] > 0) {  // 找有出边的点作为起点
        start = i;
        break;
    }
}

dfs(start);
reverse(path.begin(), path.end());  // 逆序得到正序路径
```

### 10.3 进阶技巧与模型变形

- **字典序最小**：邻接表排序后遍历
- **弗罗莱算法 (Fleury)**：边较多时不如 Hierholzer
- **中国邮路问题**：求最短回路（可重复走边），需用最短路补充奇度点
- ** De Bruijn 序列**：欧拉回路构造

### 10.4 ⚠️ 细节与致命坑点

- **当前弧优化**：`int &i = cur[u]` 必须传引用，且先 `i++` 再递归
- **边编号**：无向图用正负区分方向，取 `abs(id)` 标记
- **后序加入**：`path.push_back` 在递归之后，得到的是逆序路径
- **图不连通判断**：`path.size() == m` 才说明所有边都被遍历
- **起点选择**：必须从有边的点开始，且满足度数条件

---

## 11. 负环判定

### 11.1 算法概述与选型指南

**核心思想**：最短路经过边数超过 $N-1$ 则存在负环；或统计每个点入队次数超过 $N$。

| 方法 | 时间复杂度 | 特点 |
|:---:|:---:|:---:|
| **SPFA 计数法** | $O(NM)$ 最坏 | 统计松弛次数/入队次数 |
| **SPFA 栈优化** | 较快 | 用栈替代队列，找环更快 |
| **Bellman-Ford** | $O(NM)$ | 第 $N$ 次还能松弛则存在 |

### 11.2 核心模板

**SPFA 判负环（计数法）**：
```cpp
const int N = 510, M = 5210;
int h[N], e[M], ne[M], w[M], idx;
int dist[N], cnt[N];  // cnt记录松弛次数
bool st[N];

bool spfa(int n) {
    memset(dist, 0x3f, sizeof dist);
    memset(cnt, 0, sizeof cnt);
    memset(st, false, sizeof st);
    
    queue<int> q;
    // 所有点入队，处理不连通图
    for (int i = 1; i <= n; i++) {
        q.push(i);
        st[i] = true;
    }
    
    while (q.size()) {
        int u = q.front();
        q.pop();
        st[u] = false;
        
        for (int i = h[u]; ~i; i = ne[i]) {
            int v = e[i];
            if (dist[v] > dist[u] + w[i]) {
                dist[v] = dist[u] + w[i];
                cnt[v] = cnt[u] + 1;  // 松弛次数+1
                if (cnt[v] >= n) return true;  // 存在负环
                if (!st[v]) {
                    q.push(v);
                    st[v] = true;
                }
            }
        }
    }
    return false;
}
```

**栈优化版本**（找环更快）：
```cpp
bool spfa_stack(int n) {
    stack<int> stk;
    vector<int> dist(n + 1, INF), cnt(n + 1);
    vector<bool> in(n + 1);
    
    for (int i = 1; i <= n; i++) {
        stk.push(i);
        in[i] = true;
    }
    
    while (stk.size()) {
        int u = stk.top();
        stk.pop();
        in[u] = false;
        
        for (auto [v, w] : g[u]) {
            if (dist[v] > dist[u] + w) {
                dist[v] = dist[u] + w;
                cnt[v] = cnt[u] + 1;
                if (cnt[v] >= n) return true;
                if (!in[v]) {
                    stk.push(v);
                    in[v] = true;
                }
            }
        }
    }
    return false;
}
```

### 11.3 进阶技巧与模型变形

- **平均值最小的环**：二分答案 $mid$，边权 $-mid$ 后判负环
- **点权转边权**：点权负环需拆点
- **特定起点负环**：只从某点入队，判断该点可达的负环
- **最长路正环**：边权取负，判负环等价于原图判正环

### 11.4 ⚠️ 细节与致命坑点

- **所有点入队**：图可能不连通，必须从所有点启动 SPFA
- **cnt 数组**：`cnt[v] = cnt[u] + 1` 而非 `cnt[v]++`，前者更准确
- **判环阈值**：`cnt[v] >= n` 而非 `> n$，$n$ 条边构成环
- **初始化**：`dist` 初始化为 $INF$ 或 $0$ 均可，判环不依赖具体距离值
- **清空操作**：多组数据时注意清空 `idx`、`h`、`cnt` 等数组

---

*笔记整理完成，祝竞赛/面试顺利！*
