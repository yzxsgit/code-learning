# 📚 图论算法复习笔记合集

## 目录

1. 单源最短路 (SSSP)
    
2. Floyd-Warshall 与 传递闭包
    
3. 最小生成树 (MST)
    
4. 负环判定与 0/1 分数规划
    
5. 差分约束系统
    
6. 强连通分量 (SCC) 与 Tarjan
    
7. 无向图双连通分量 (桥与割)
    
8. 最近公共祖先 (LCA)
    
9. 二分图 (判定、匹配与覆盖)
    
10. 欧拉回路与欧拉路径

---

## 1. 单源最短路 (SSSP)

### 1.1 算法概述与选择指南

在拿到一道题时，首先根据**边权**和**图的规模**选择算法：

| 场景  | 边权特征 | 推荐算法 | 时间复杂度 | 典型例题 |
| --- | --- | --- | --- | --- |
| **无权图** | 均为 1 | **BFS** | $O(V+E)$ | 最优乘车 |
| **0/1 图** | 只有 0 和 1 | **双端队列 BFS** | $O(V+E)$ | 通信线路 (二分check) |
| **非负权** | $\ge 0$ | **Dijkstra (堆优化)** | $O(E \log V)$ | 拯救大兵瑞恩, 昂贵的聘礼 |
| **一般图** | 含负权 (无负环) | **SPFA** | $O(kE)$ | 香甜的黄油 |
| **稠密图** | $E \approx V^2$ | **朴素 Dijkstra** | $O(V^2)$ | 最小花费 |
| **小规模** | $N \le 200$ | **Floyd** | $O(N^3)$ | 信使  |

### 1.2 核心模板

#### Dijkstra (堆优化版)

适用于绝大多数正权图问题。**注意**：`vis` 数组是必须的，防止同一个点被冗余扩展。

```cpp
typedef pair<int, int> PII; // {distance, node}

void dijkstra(int start) {
    memset(dist, 0x3f, sizeof dist);
    dist[start] = 0;
    priority_queue<PII, vector<PII>, greater<PII>> heap;
    heap.push({0, start});

    while (heap.size()) {
        auto t = heap.top(); heap.pop();
        int ver = t.second, distance = t.first;

        if (st[ver]) continue; // 懒惰删除的关键
        st[ver] = true;

        for (int i = h[ver]; ~i; i = ne[i]) {
            int j = e[i];
            if (dist[j] > distance + w[i]) {
                dist[j] = distance + w[i];
                heap.push({dist[j], j});
            }
        }
    }
}
```

#### SPFA (队列优化 Bellman-Ford)

适用于含负权边或判断负环。

```cpp
void spfa(int start) {
    memset(dist, 0x3f, sizeof dist);
    memset(st, 0, sizeof st); // st表示"是否在队列中"
    
    dist[start] = 0;
    queue<int> q;
    q.push(start);
    st[start] = true;

    while (q.size()) {
        int t = q.front(); q.pop();
        st[t] = false;

        for (int i = h[t]; ~i; i = ne[i]) {
            int j = e[i];
            if (dist[j] > dist[t] + w[i]) {
                dist[j] = dist[t] + w[i];
                if (!st[j]) {
                    q.push(j);
                    st[j] = true;
                }
            }
        }
    }
}
```

### 1.3 进阶技巧与建模

1.  **虚拟源点**：多起点问题，建立虚拟点 `0` 连向所有起点，边权为0。
    
2.  **拆点与分层图**：当状态不仅由节点编号决定时（如：剩余免费次数、钥匙状态），将节点 $u$拆分为 $u_{state}$。
    
3.  **二分答案 + 0/1 最短路**：求“最大边的最小值”或“第K大边的最小值”。二分 `bound`，大于 `bound` 边权为1，否则为0，跑双端队列BFS。
    
4.  **乘法最短路**：权值是相乘（如汇率），可取 `-log` 转化为加法，或修改 Dijkstra 松弛条件。
    
5.  **最短路计数**：在松弛时维护 `cnt` 数组。若 `dist[j] > dist[t]+w` 则覆盖 `cnt`；若相等则累加。需满足拓扑序（Dijkstra/BFS）。
    

### 1.4 细节与坑点

-   **INF 设置**：`0x3f3f3f3f` 适合 `int` 加法。若涉及 `long long` 或乘法，需更大值。
    
-   **数组大小**：链式前向星 `e`, `ne`, `w` 数组大小应为边数 $M$（无向图为 $2M$）。
    
-   **SPFA 劣化**：网格图或构造数据可能使 SPFA 退化为 $O(VE)$，正权图首选 Dijkstra。
    

---

## 2. Floyd-Warshall 与 传递闭包

### 2.1 算法概述

**Floyd-Warshall** 是解决 **多源最短路径** 的动态规划算法。

-   **复杂度**：$O(N^3)$，一般 $N \le 500$。
    
-   **状态**：$D[i][j]$ 表示从 $i$到 $j$的最短路。
    

### 2.2 核心模板

#### 标准 Floyd

```cpp
// 初始化：d[i][i]=0, d[i][j]=INF
void floyd(int n) {
    for (int k = 1; k <= n; k++) { // k 必须在最外层
        for (int i = 1; i <= n; i++) {
            for (int j = 1; j <= n; j++) {
                // 防止溢出判断
                if (d[i][k] != INF && d[k][j] != INF)
                    d[i][j] = min(d[i][j], d[i][k] + d[k][j]);
            }
        }
    }
}
```

#### 传递闭包 (Bitset 优化)

用于解决连通性问题，`d[i][j]=1` 表示 $i$可达 $j$。

```cpp
bitset<N> d[N]; 
void floyd_closure(int n) {
    for (int k = 1; k <= n; k++)
        for (int i = 1; i <= n; i++)
            if (d[i][k]) d[i] |= d[k]; // 位运算优化，速度极大提升
}
```

### 2.3 进阶技巧

1.  **最小环问题**：在 $k$层循环开始时，利用 $k$作为最大编号节点，计算 `d[i][j] + g[j][k] + g[k][i]` 更新最小环，然后再进行 Floyd 松弛。
    
2.  **倍增 Floyd (广义矩阵乘法)**：求“恰好经过 $K$条边”的最短路。利用矩阵乘法结合律（$C_{ij} = \min(A_{ik} + B_{kj})$）和快速幂，复杂度 $O(N^3 \log K)$。
    

### 2.4 细节与坑点

-   **循环顺序**： **$k$必须在最外层**，否则状态转移错误。
    
-   **INF 溢出**：注意 `d[i][k] + d[k][j]` 是否会爆 `int`。
    

---

## 3. 最小生成树 (MST)

### 3.1 算法概述与选择指南

| 算法  | 复杂度 | 适用场景 |
| --- | --- | --- |
| **Prim (朴素)** | $O(N^2)$ | **稠密图** (点少边多) |
| **Kruskal** | $O(E \log E)$ | **稀疏图** (绝大多数情况) |

### 3.2 核心模板

#### Kruskal (推荐)

```cpp
struct Edge { int a, b, w; } e[M];
bool operator<(const Edge &a, const Edge &b) { return a.w < b.w; }

int find(int x) { if (p[x]!=x) p[x]=find(p[x]); return p[x]; }

int kruskal() {
    sort(e, e + m);
    for (int i = 1; i <= n; i++) p[i] = i;
    int res = 0, cnt = 0;
    for (int i = 0; i < m; i++) {
        int a = find(e[i].a), b = find(e[i].b);
        if (a != b) {
            p[a] = b;
            res += e[i].w;
            cnt++;
        }
    }
    return res;
}
```

### 3.3 进阶技巧

1.  **虚拟源点**：在点上建立设施有代价时，建立虚拟点 `0`，将建站代价转化为边权，求 MST。
    
2.  **必选边处理**：在 Kruskal 排序前，先将必选边 union，计算初始代价。
    
3.  **次小生成树**：
    
    -   先求 MST。
        
    -   枚举非树边 $(u, v, w)$。
        
    -   在 MST 上求 $u \to v$路径上的**最大边** $val_1$和 **严格次大边** $val_2$。
        
    -   若 $w > val_1$，替换后代价增加 $w - val_1$；若 $w == val_1$，增加 $w - val_2$。
        
4.  **瓶颈生成树**：最小生成树一定是瓶颈生成树（最大边权最小的生成树）。
    

### 3.4 细节与坑点

-   **连通性检查**：Prim 结束时需检查是否所有点都在集合中；Kruskal 检查边数是否为 $N-1$。
    
-   **精度**：涉及几何距离时注意 `double` 精度和输出格式。
    

---

## 4. 负环判定与 0/1 分数规划

### 4.1 算法概述

SPFA 是判定负环的标准算法（抽屉原理）。

### 4.2 核心模板

#### SPFA 判负环

```cpp
bool spfa() {
    // 判全图负环，所有点入队
    for (int i = 1; i <= n; i++) { q.push(i); st[i] = true; }
    
    while (q.size()) {
        int t = q.front(); q.pop(); st[t] = false;
        for (int i = h[t]; ~i; i = ne[i]) {
            int j = e[i];
            if (dist[j] > dist[t] + w[i]) {
                dist[j] = dist[t] + w[i];
                cnt[j] = cnt[t] + 1;
                if (cnt[j] >= n) return true; // 存在负环
                if (!st[j]) { q.push(j); st[j] = true; }
            }
        }
    }
    return false;
}
```

### 4.3 进阶技巧：0/1 分数规划

-   **目标**：求环使得 $\frac{\sum v_i}{\sum w_i}$最大。
    
-   **方法**：
    
    1.  二分答案 `mid`。
        
    2.  重构边权：$NewW = v - mid \times w$。
        
    3.  判定：检查图中是否存在**正环**（求最长路，`dist[j] < dist[t] + NewW`）。
        
-   **玄学优化**：若 SPFA 更新次数超过常数（如 `2*N` 或 `10000`），直接判定有环（应对超时）。
    

### 4.4 细节与坑点

-   **初始化**：判全图负环需将所有点入队，`dist` 初始化为 0。
    
-   **正环 vs 负环**：求最大比率判正环（最长路），求最小比率判负环（最短路）。
    

---

## 5. 差分约束系统

### 5.1 算法概述

将不等式组转化为图论最长/最短路问题。

### 5.2 转化指南 (背诵)

| 目标  | 不等式 | 转化边 | 初始值 | 判无解 | 算法  |
| --- | --- | --- | --- | --- | --- |
| **求最小** | $x_i \ge x_j + c$ | $j \to i, w=c$ | $-\infty$ | **正环** | SPFA (最长路) |
| **求最大** | $x_i \le x_j + c$ | $j \to i, w=c$ | $+\infty$ | **负环** | SPFA (最短路) |

### 5.3 进阶技巧

1.  **Tarjan 优化**：若边权非负求最长路，可先缩点。若 SCC 内有正权边则无解（正环）；否则缩点后为 DAG，跑线性 DP。
    
2.  **超级源点**：建立点 `0` 连向所有点，保证图连通，处理 $x_i \ge c$($x_i \ge x_0 + c$)。
    
3.  **区间约束**：对于前缀和 $S_i$，注意隐含约束 $S_i - S_{i-1} \ge 0$。
    

### 5.4 细节与坑点

-   **栈 vs 队列**：SPFA 用栈（DFS 序）判环通常更快，但求数值不稳定。
    
-   **数据范围**：差分约束累加后易爆 `int`，建议 `long long`。
    

---

## 6. 强连通分量 (SCC) 与 Tarjan

### 6.1 算法概述

**SCC**：有向图中任意两点互达的极大子图。 **Tarjan**：基于 DFS，利用 `dfn` (时间戳) 和 `low` (追溯值) 求解。

### 6.2 核心模板

```cpp
void tarjan(int u) {
    dfn[u] = low[u] = ++timer;
    stk.push(u); in_stk[u] = true;
    for (int v : adj[u]) {
        if (!dfn[v]) {
            tarjan(v);
            low[u] = min(low[u], low[v]);
        } else if (in_stk[v]) {
            low[u] = min(low[u], dfn[v]);
        }
    }
    if (dfn[u] == low[u]) {
        ++scc_cnt;
        int y;
        do {
            y = stk.top(); stk.pop();
            in_stk[y] = false;
            id[y] = scc_cnt;
        } while (y != u);
    }
}
```

### 6.3 进阶技巧

1.  **缩点**：将 SCC 缩为一个点，得到 DAG。
    
2.  **DAG DP**：SCC 编号具有**逆拓扑序**，可直接倒序遍历 `scc_cnt` 到 1 进行 DP。
    
3.  **出入度分析**：
    
    -   若 DAG 只有一个出度为0的点，该点即为“被所有人关注”的集合。
        
    -   全图强连通需加边数：$\max(\text{源点数}, \text{汇点数})$。
        

### 6.4 细节与坑点

-   **重边**：缩点后两个 SCC 间可能有多条边，DP 或统计时需去重。
    
-   **栈标记**：`in_stk` 仅在出栈时取消，用于区分横叉边和返祖边。
    

---

## 7. 无向图双连通分量 (桥与割点)

### 7.1 算法概述

-   **边双 (e-DCC)**：无桥，去掉任意边仍连通。判定：`low[v] > dfn[u]` (桥)。
    
-   **点双 (v-DCC)**：无割点，去掉任意点仍连通。判定：`low[v] >= dfn[u]` (割点)。
    

### 7.2 核心模板

#### 求桥 (Bridge)

需处理反向边（重边时用边索引判断）。

```cpp
void tarjan(int u, int in_edge) {
    dfn[u] = low[u] = ++timer;
    for (int i = h[u]; ~i; i = ne[i]) {
        int v = e[i];
        if (!dfn[v]) {
            tarjan(v, i);
            low[u] = min(low[u], low[v]);
            if (low[v] > dfn[u]) is_bridge[i] = true;
        } else if (i != (in_edge ^ 1)) 
            low[u] = min(low[u], dfn[v]);
    }
}
```

#### 求割点 (Cut Vertex)

```cpp
void tarjan(int u) {
    dfn[u] = low[u] = ++timer;
    int children = 0;
    for (int v : adj[u]) {
        if (!dfn[v]) {
            tarjan(v);
            low[u] = min(low[u], low[v]);
            if (low[v] >= dfn[u]) {
                children++;
                if (u != root || children > 1) is_cut[u] = true;
            }
        } else low[u] = min(low[u], dfn[v]);
    }
}
```

### 7.3 进阶技巧

1.  **边双缩点**：去掉桥后缩点为树。加最少边使全图变双连通 = $(\text{叶子数}+1)/2$。
    
2.  **点双缩点**：圆方树 (Block-Cut Tree)。
    
3.  **分类讨论**：点双题目（如矿场搭建）常需根据割点数量分类讨论（0个、1个、$\ge 2$个）。
    

---

## 8. 最近公共祖先 (LCA)

### 8.1 算法概述

| 算法  | 预处理 | 查询  | 特点  |
| --- | --- | --- | --- |
| **倍增法** | $O(N \log N)$ | $O(\log N)$ | 在线，易维护路径信息 |
| **Tarjan** | $O(N)$ | $O(1)$ | 离线，利用并查集，常数小 |

### 8.2 核心模板 (倍增法)

```cpp
int lca(int a, int b) {
    if (depth[a] < depth[b]) swap(a, b);
    for (int k = 15; k >= 0; k--)
        if (depth[a] - depth[b] >= (1 << k)) a = fa[a][k];
    if (a == b) return a;
    for (int k = 15; k >= 0; k--)
        if (fa[a][k] != fa[b][k]) {
            a = fa[a][k]; b = fa[b][k];
        }
    return fa[a][0];
}
```

### 8.3 进阶技巧

1.  **树上差分**：
    
    -   **点差分** (覆盖点)：`d[u]++, d[v]++, d[lca]--, d[fa[lca]]--`。
        
    -   **边差分** (覆盖边)：`d[u]++, d[v]++, d[lca]-=2`。
        
2.  **树上距离**：`dist(u, v) = d[u] + d[v] - 2*d[lca]`。
    
3.  **路径信息**：倍增时可维护路径最大值/次大值，用于次小生成树。
    

### 8.4 细节与坑点

-   **数组大小**：倍增数组 `fa[N][20]`，注意 $2^{20} > N$。
    
-   **预处理**：通常用 BFS 预处理 `depth` 和 `fa` 防止爆栈。
    

---

## 9. 二分图 (判定、匹配与覆盖)

### 9.1 算法概述

-   **判定**：染色法 (无奇数环)。
    
-   **匹配**：匈牙利算法 (增广路)。
    

### 9.2 核心模板 (匈牙利算法)

```cpp
bool find(int u) {
    for (int v : adj[u]) {
        if (!st[v]) {
            st[v] = true;
            if (!match[v] || find(match[v])) {
                match[v] = u;
                return true;
            }
        }
    }
    return false;
}
```

### 9.3 三大经典模型 (背诵)

1.  **最小点覆盖** = 最大匹配。
    
    -   例：机器任务 (选最少的模式覆盖所有任务)。
        
2.  **最大独立集** = 总点数 - 最大匹配。
    
    -   例：骑士放置 (互不攻击的最多点)。
        
3.  **最小路径点覆盖 (DAG)** = 总点数 - 拆点二分图最大匹配。
    
    -   例：捉迷藏 (Dilworth定理)。
        

### 9.4 细节与坑点

-   **st 数组**：每次 `find` 前必须清空 `st`。
    
-   **坐标映射**：网格图可黑白染色判二分，坐标 $(r, c)$可映射为 ID。
    

---

## 10. 欧拉回路与欧拉路径

### 10.1 算法概述

-   **欧拉回路**：经过每条边一次且回到起点。
    
-   **欧拉路径**：经过每条边一次，起点终点不同。
    

### 10.2 判定条件

| 类型  | 无向图 | 有向图 |
| --- | --- | --- |
| **回路** | 度数为偶 | $入度=出度$ |
| **路径** | 2个奇度点 | $出-入=1$ |

**前提**：忽略孤立点后图连通。

### 10.3 核心模板 (Hierholzer DFS)

```cpp
void dfs(int u) {
    // 引用 &i 实现当前弧优化
    for (int &i = cur[u]; i < adj[u].size(); ) {
        int v = adj[u][i].first;
        i++; // 删边
        if (used[edge_id]) continue;
        used[edge_id] = true;
        dfs(v);
    }
    path.push_back(u); // 回溯时入栈
}
// 最后需 reverse(path)
```

### 10.4 进阶技巧

1.  **单词接龙**：将单词看作边，首尾字符看作点，转化为有向图欧拉路径。
    
2.  **混合图欧拉回路**：结合网络流求解。
    

### 10.5 细节与坑点

-   **逆序输出**：记录的是出栈顺序。
    
-   **当前弧优化**：必须加，否则稠密图 $O(M^2)$。
    
-   **连通性**：判定度数前必须先用并查集判连通。