# Codeforces Round 1080 (Div. 3) - Problem F: Parabola Independence

## 题目描述

给定 `n` 个二次函数 $f_i(x) = a_i x^2 + b_i x + c_i$。

**定义**：
- 两个函数 `f` 和 `g` 如果图像没有交点，则称其"独立"
- 一个函数集合中如果任意两个函数都独立，则称其"有序"

对于每个 $f_i$，求包含 $f_i$ 的最大有序子集的规模。

### 输入格式
- 第一行：整数 `t` $(1 \le t \le 10^4)$，测试用例数量
- 每个测试用例：
  - 第一行：整数 `n` $(1 \le n \le 3000)$
  - 接下来 `n` 行：每行三个整数 $a_i, b_i, c_i$ $(-10^6 \le a_i, b_i, c_i \le 10^6, a_i \neq 0)$
  
- 所有函数互不相同
- 所有测试用例的 $\sum n^2 \le 3000^2$

### 输出格式
- 对每个测试用例，输出 `n` 个整数，第 `i` 个表示包含 $f_i$ 的最大有序子集大小

### 示例
```
输入：
2
3
1 0 0
1 0 1
-1 0 2
4
1 0 0
1 0 2
1 0 4
1 0 6

输出：
2 2 1
1 2 2 1
```

---

## 一、题目解析

### 题意理解
我们有多个二次函数，需要找出包含每个函数的最大"有序"集合。

**独立的条件**：两个二次函数图像不相交。

### 核心问题
**两个二次函数何时相交？**

设 $f(x) = a_1 x^2 + b_1 x + c_1$，$g(x) = a_2 x^2 + b_2 x + c_2$

令 $h(x) = f(x) - g(x) = (a_1-a_2)x^2 + (b_1-b_2)x + (c_1-c_2)$

$f$ 和 $g$ 不相交 $\iff$ $h(x) = 0$ 无实数解

**情况1**：$a_1 \neq a_2$

$h(x)$ 是二次函数，无实数解 $\iff$ 判别式 $\Delta < 0$

$\Delta = (b_1-b_2)^2 - 4(a_1-a_2)(c_1-c_2) < 0$

**情况2**：$a_1 = a_2, b_1 = b_2, c_1 \neq c_2$

$h(x) = c_1 - c_2$ 是常数且非零，无零点，独立。

### 解题思路

**关键观察**：
- 按 $(a, b, c)$ 排序后，独立性具有传递性
- 即如果 $f_i$ 和 $f_j$ 独立，$f_j$ 和 $f_k$ 独立，且 $i < j < k$，则 $f_i$ 和 $f_k$ 也独立

**证明**：
- 两个二次函数的差也是二次函数（或线性/常数）
- 判别式小于0意味着差恒正或恒负
- 如果 $f_i - f_j > 0$ 且 $f_j - f_k > 0$，则 $f_i - f_k = (f_i - f_j) + (f_j - f_k) > 0$

因此问题转化为**最长链问题**：
1. 按 $(a, b, c)$ 排序
2. 计算以每个点为结尾的最长有序链（`pre[i]`）
3. 计算以每个点为起点的最长有序链（`suf[i]`）
4. 包含 $f_i$ 的最大有序子集大小 = `pre[i] + suf[i] - 1`

---

## 二、知识点归类

| 类别 | 内容 |
|------|------|
| **主要算法** | 动态规划、偏序集最长链 |
| **数据结构** | 数组、结构体 |
| **编程技巧** | 排序、传递性分析 |
| **难度等级** | ⭐⭐⭐⭐ 中等-困难 |

---

## 三、关键提示点

### 易错点提醒
- ❌ 忘记处理 $a_1 = a_2$ 的特殊情况
- ❌ 判别式计算溢出（使用long long）
- ❌ 排序时的关键字顺序错误

### 边界条件
- $n = 1$：答案为1
- 所有抛物线都相交：每个答案都是1
- 所有抛物线互相独立：答案为n

### 优化思路
- $O(n^2)$ 的DP是本题的最优复杂度（因为 $\sum n^2$ 有限制）

### 常见陷阱
- 判别式等于0时相交（有重根）
- 二次项系数为0时不是二次函数

---

## 四、代码解析（详细中文注释）

```cpp
#include <bits/stdc++.h>
using namespace std;

const int N = 3000;        // 最大数据范围

// 二次函数结构体
struct bruh {
    long long a, b, c;     // 二次函数的三个系数
    int id;                // 原始下标，用于输出答案
} f[N + 10];

int n;                     // 函数数量
int pre[N + 10];           // pre[i]: 以i结尾的最长有序链长度
int suf[N + 10];           // suf[i]: 以i开头的最长有序链长度
int ans[N + 10];           // ans[id]: 包含该函数的最大有序子集大小

// 检查u和v是否独立（u在v前面，即u的a,b,c都小于等于v）
// 注意：调用时保证u.a <= v.a
bool check(bruh u, bruh v) {
    if (u.a < v.a) {
        // 判别式判断：(b1-b2)^2 < 4*(a1-a2)*(c1-c2)
        // 注意a1-a2 < 0，所以右边需要为负数才能使不等式成立
        return (u.b - v.b) * (u.b - v.b) < 4LL * (u.a - v.a) * (u.c - v.c);
    }
    // u.a == v.a 的情况
    // 需要u.b == v.b 且 u.c < v.c（保证严格偏序）
    return u.a == v.a && u.b == v.b && u.c < v.c;
}

// 排序比较函数：按(a, b, c)字典序排序
bool cmp(bruh u, bruh v) {
    if (u.a != v.a) return u.a < v.a;
    if (u.b != v.b) return u.b < v.b;
    return u.c < v.c;
}

void work() {
    cin >> n;
    
    // 读取n个二次函数
    for (int i = 1; i <= n; ++i) {
        cin >> f[i].a >> f[i].b >> f[i].c;
        f[i].id = i;  // 记录原始编号
    }
    
    // 按(a, b, c)排序，建立偏序关系
    sort(f + 1, f + n + 1, cmp);
    
    // 计算pre[i]: 以i结尾的最长有序链
    // pre[i] = max(pre[j]) + 1，其中j < i且f[j]和f[i]独立
    for (int i = 1; i <= n; ++i) {
        pre[i] = 1;  // 至少包含自己
        for (int j = 1; j < i; ++j) {
            // 如果f[j]和f[i]独立，可以扩展
            if (check(f[j], f[i])) {
                pre[i] = max(pre[i], pre[j] + 1);
            }
        }
    }
    
    // 计算suf[i]: 以i开头的最长有序链
    // suf[i] = max(suf[j]) + 1，其中j > i且f[i]和f[j]独立
    for (int i = n; i >= 1; --i) {
        suf[i] = 1;  // 至少包含自己
        for (int j = n; j > i; --j) {
            // 如果f[i]和f[j]独立，可以扩展
            if (check(f[i], f[j])) {
                suf[i] = max(suf[i], suf[j] + 1);
            }
        }
    }
    
    // 计算答案：包含f[i]的最大有序子集 = 以i结尾的链 + 以i开头的链 - 1
    // -1是因为i被计算了两次
    for (int i = 1; i <= n; ++i) {
        ans[f[i].id] = pre[i] + suf[i] - 1;
    }
    
    // 按原始顺序输出答案
    for (int i = 1; i <= n; ++i) {
        cout << ans[i] << ' ';
    }
    cout << '\n';
}

int main() {
    int T;              // 测试用例数量
    cin >> T;
    while (T--) work();
    return 0;
}
```

### 变量含义
| 变量 | 含义 |
|------|------|
| `f[i]` | 第i个二次函数（排序后） |
| `f[i].a, b, c` | 二次函数系数 |
| `f[i].id` | 原始编号 |
| `pre[i]` | 以i结尾的最长有序链长度 |
| `suf[i]` | 以i开头的最长有序链长度 |
| `ans[id]` | 包含原始编号为id的函数的最大有序子集大小 |

### 算法步骤
1. 读取所有二次函数
2. 按 $(a, b, c)$ 排序
3. 计算 `pre[i]`：从左到右DP，找以i结尾的最长链
4. 计算 `suf[i]`：从右到左DP，找以i开头的最长链
5. `ans[id] = pre[i] + suf[i] - 1`
6. 按原始顺序输出

### 关键操作的作用
- `sort(f + 1, f + n + 1, cmp)`：建立偏序关系的基础
- `check(f[j], f[i])`：判断两个函数是否独立（判别式分析）
- `pre[i] + suf[i] - 1`：合并两个方向的链，减去重复计算的i

### 时间复杂度分析
- **时间复杂度**：$O(n^2)$
  - 排序：$O(n \log n)$
  - 两遍DP：$O(n^2)$
- **空间复杂度**：$O(n)$

---

## 五、数学推导详解

### 判别式条件
两个二次函数 $f(x) = a_1 x^2 + b_1 x + c_1$ 和 $g(x) = a_2 x^2 + b_2 x + c_2$

差函数：$h(x) = (a_1-a_2)x^2 + (b_1-b_2)x + (c_1-c_2)$

不相交条件：$h(x) \neq 0$ 对所有 $x$ 成立

**当 $a_1 \neq a_2$ 时**：
- $h(x)$ 是二次函数
- 无实根 $\iff \Delta = (b_1-b_2)^2 - 4(a_1-a_2)(c_1-c_2) < 0$

**当 $a_1 = a_2$ 时**：
- $h(x) = (b_1-b_2)x + (c_1-c_2)$
- 如果 $b_1 \neq b_2$，是一次函数，必有根
- 如果 $b_1 = b_2$：
  - $c_1 = c_2$：$h(x) = 0$，处处相交（题目保证函数不同，不会出现）
  - $c_1 \neq c_2$：$h(x) \neq 0$ 恒成立，不相交

### 传递性证明
若 $f, g$ 独立且 $g, h$ 独立，则 $f, h$ 独立。

**证明**：
- 设 $f(x) - g(x) > 0$ 对所有 $x$ 成立（或都 < 0）
- 设 $g(x) - h(x) > 0$ 对所有 $x$ 成立（或都 < 0）
- 则 $f(x) - h(x) = (f(x) - g(x)) + (g(x) - h(x)) > 0$ 对所有 $x$ 成立

因此独立性在排序后具有传递性，构成**偏序关系**。

---

## 六、总结

本题是一道精妙的**偏序集最长链**问题，关键在于：
1. 数学分析：判别式判断独立性
2. 关键发现：独立性具有传递性
3. 算法转化：转化为最长链DP问题

**核心思想**：数学分析 + DAG最长路
