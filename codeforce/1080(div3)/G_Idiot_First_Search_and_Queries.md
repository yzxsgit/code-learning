# Codeforces Round 1080 (Div. 3) - Problem G: Idiot First Search and Queries

## 题目描述

这是 Problem E 的扩展版本，增加查询功能。

Bob 在一个有 $N+1$ 个节点的二叉树中进行"愚蠢搜索"（规则同E题）。

有 $q$ 个查询，每个查询给定 $v_j$ 和 $k_j$，问 Bob 从节点 $v_j$ 出发，经过 $k_j$ 秒后所在的位置。

### 输入格式
- 第一行：整数 `t` $(t \le 10^4)$，测试用例数量
- 每个测试用例：
  - 第一行：两个整数 `n, q` $(1 \le n \le 3 \cdot 10^5, q \le 4 \cdot 10^5)$
  - 接下来 `n` 行：每行两个整数 $l_i, r_i$，表示节点 `i` 的左右子节点
  - 接下来 `q` 行：每行两个整数 $v_j, k_j$
  
- 所有测试用例的 $\sum n \le 3 \cdot 10^5$，$\sum q \le 4 \cdot 10^5$
- $0 \le k_j < \min(10^9+7, T_{v_j})$，其中 $T_{v_j}$ 是从 $v_j$ 到根的总时间

### 输出格式
- 对每个测试用例，输出 `q` 个答案，表示每个查询 $k_j$ 秒后 Bob 的位置

### 示例
```
输入：
1
7 5
0 0
3 4
0 0
5 6
0 0
0 0
1 2
1 0
2 3
3 1
4 5
5 10

输出：
1 2 3 6 5 
```

---

## 一、题目解析

### 题意理解
基于 E 题的"愚蠢搜索"规则，现在需要回答多个查询：从节点 v 出发，k 秒后在哪里？

### 核心问题
**Bob 的运动轨迹分析**：
1. 从节点 v 出发，首先会遍历 v 的子树（类似DFS），直到走出子树
2. 走出子树后，向上跳到父节点
3. 继续向上，直到有足够的时间回到根或走出整棵树

**关键观察**：
- 设 `dp[v]` 为从 v 出发走出子树的时间（同E题）
- 设 `sum[v]` 为从 v 出发到达根的总时间
- Bob 的路径是：先在自己子树内游荡，然后一路向上到根

### 解题思路

**步骤1：预处理**
- 计算 `dp[v]`：走出子树的时间（后序遍历）
- 计算 `sum[v]`：从 v 到根的总时间（实际是E题的答案）
- 计算倍增数组 `fa[k][v]`：v 的 $2^k$ 级祖先
- 预处理欧拉序 `et`：DFS序列，记录每个节点在何时被访问

**步骤2：回答查询**
对于查询 $(v, k)$：
1. 首先向上倍增，找到最高的祖先 `u`，使得 `sum[v] - sum[u] <= k`
   - 即 Bob 有足够时间从 v 走到 u
2. 剩余时间 `rem = k - (sum[v] - sum[u])`
3. 在欧拉序上，从 u 的位置往后走 `rem` 步，就是答案

---

## 二、知识点归类

| 类别 | 内容 |
|------|------|
| **主要算法** | 倍增法、欧拉序、树形DP |
| **数据结构** | 树、倍增数组、欧拉序列 |
| **编程技巧** | LCA变种、序列化树 |
| **难度等级** | ⭐⭐⭐⭐ 中等-困难 |

---

## 三、关键提示点

### 易错点提醒
- ❌ 倍增数组的初始化（fa[0][root] = 0）
- ❌ 欧拉序的长度是 2n-1 或 3n 级别
- ❌ 时间比较时的符号方向

### 边界条件
- k = 0：答案就是 v 本身
- 走到根节点的情况
- 叶子节点的处理

### 优化思路
- 倍增法是标准做法，时间复杂度 $O((n+q) \log n)$

### 常见陷阱
- 混淆 `dp` 和 `sum` 的含义
- 欧拉序的下标越界
- 倍增时的方向错误

---

## 四、代码解析（详细中文注释）

```cpp
#include <bits/stdc++.h>
using namespace std;

const int N = 300001;      // 最大节点数
const int B = 19;          // 倍增层数，2^19 > 5e5

int n, q;                  // n:节点数, q:查询数
int ls[N + 10], rs[N + 10]; // 左右子节点
int fa[B + 1][N + 10];      // fa[k][v]: v的2^k级祖先
int sz[N + 10];            // sz[v]: 子树大小（节点数）
long long dp[N + 10];       // dp[v]: 从v走出子树的时间（同E题）
int et[2 * N + 10];         // 欧拉序数组
int pos[N + 10];            // pos[v]: v在欧拉序中的首次出现位置
int cnt;                    // 欧拉序计数器

// 第一次DFS：计算倍增数组和子树大小
void dfs1(int u) {
    // 计算倍增数组
    for (int i = 1; i <= B; ++i) {
        fa[i][u] = fa[i - 1][fa[i - 1][u]];
    }
    
    sz[u] = 1;      // 子树大小至少为1（自己）
    dp[u] = 0;      // 初始化dp
    
    // 叶子节点
    if (!ls[u]) return;
    
    // 设置子节点的父节点
    fa[0][ls[u]] = u;
    fa[0][rs[u]] = u;
    
    // 递归处理子节点
    dfs1(ls[u]);
    dfs1(rs[u]);
    
    // 计算子树大小
    sz[u] += sz[ls[u]] + sz[rs[u]];
}

// 第二次DFS：计算dp值（从v走出子树的时间）
// 注意这里的dp定义略有不同：dp[v]表示从v出发，到达父节点的时间
void dfs2(int u) {
    // dp[u] = dp[父] + 2*子树大小 - 1
    // 这个公式推导：走出子树需要遍历所有子树节点并返回
    dp[u] = dp[fa[0][u]] + 2LL * sz[u] - 1LL;
    
    if (!ls[u]) return;
    
    dfs2(ls[u]);
    dfs2(rs[u]);
}

// 第三次DFS：生成欧拉序
// 欧拉序记录DFS遍历的顺序，每个节点可能出现多次
void dfs3(int u) {
    et[++cnt] = u;              // 记录进入节点u
    if (!pos[u]) pos[u] = cnt;  // 记录u的首次出现位置
    
    // 叶子节点
    if (!ls[u]) return;
    
    // 遍历左子树
    dfs3(ls[u]);
    et[++cnt] = u;              // 从左子树返回
    
    // 遍历右子树
    dfs3(rs[u]);
    et[++cnt] = u;              // 从右子树返回
}

void work() {
    cin >> n >> q;
    cnt = 0;  // 重置欧拉序计数器
    
    // 读取树的结构
    for (int i = 1; i <= n; ++i) {
        cin >> ls[i] >> rs[i];
        fa[0][i] = 0;   // 初始化父节点
        pos[i] = 0;     // 初始化位置
    }
    
    // 节点0是虚拟根，节点1和2是实际根的两个子节点
    // 或者按照题目设定，节点1是实际的起点
    fa[0][1] = 0;  // 节点1的父节点是0（虚拟根）
    
    // 三次DFS预处理
    dfs1(1);  // 计算倍增数组和子树大小
    dfs2(1);  // 计算dp值
    dfs3(1);  // 生成欧拉序
    
    // 处理查询
    while (q--) {
        int u, k;
        cin >> u >> k;
        
        int cur = u;
        
        // 倍增向上跳，找到最高的祖先，使得dp[u] - dp[祖先] <= k
        // 即 Bob 能在k秒内从u走到这个祖先
        for (int i = B; i >= 0; --i) {
            // 如果存在2^i级祖先，且从u走到该祖先的时间不超过k
            if (fa[i][cur] && dp[u] - dp[fa[i][cur]] <= k) {
                cur = fa[i][cur];  // 向上跳
            }
        }
        
        // 此时 cur 是满足条件的最高祖先
        // 计算剩余时间：k减去从u走到cur的时间
        long long rem = k - (dp[u] - dp[cur]);
        
        // 在欧拉序上，从cur的位置往后走rem步，就是答案
        cout << et[pos[cur] + rem] << ' ';
    }
    
    cout << '\n';
}

int main() {
    ios::sync_with_stdio(0); 
    cin.tie(0); 
    cout.tie(0);
    
    int T;              // 测试用例数量
    cin >> T;
    while (T--) work();
    return 0;
}
```

### 变量含义
| 变量 | 含义 |
|------|------|
| `fa[k][v]` | v的$2^k$级祖先 |
| `sz[v]` | v的子树大小（包含v） |
| `dp[v]` | 从v出发走出子树并到达父节点的时间 |
| `et[i]` | 欧拉序第i个位置的节点 |
| `pos[v]` | v在欧拉序中的首次出现位置 |
| `cur` | 倍增后找到的祖先节点 |
| `rem` | 剩余时间 |

### 算法步骤
1. **读取输入**：树的结构和查询
2. **dfs1**：计算倍增数组 `fa` 和子树大小 `sz`
3. **dfs2**：计算 `dp` 值（从v走出子树的时间）
4. **dfs3**：生成欧拉序 `et`
5. **处理查询**：
   - 倍增找到最高可达祖先 `cur`
   - 计算剩余时间 `rem`
   - 在欧拉序上查答案

### 关键操作的作用
- `fa[i][u] = fa[i - 1][fa[i - 1][u]]`：倍增数组的递推计算
- `dp[u] = dp[fa[0][u]] + 2LL * sz[u] - 1LL`：树形DP计算走出子树的时间
- `for (int i = B; i >= 0; --i)`：倍增查询的标准写法
- `et[pos[cur] + rem]`：利用欧拉序快速定位

### 时间复杂度分析
- **预处理**：$O(n \log n)$
  - 三次DFS，倍增数组计算
- **每次查询**：$O(\log n)$
  - 倍增跳跃
- **总复杂度**：$O((n + q) \log n)$

---

## 五、欧拉序与查询的关系

### 为什么欧拉序有效？
Bob 的运动轨迹实际上就是 **DFS 遍历顺序**：
1. 进入一个节点（记录）
2. 遍历左子树
3. 返回节点（记录）
4. 遍历右子树
5. 返回节点（记录）并退出

### 查询过程分解
对于查询 $(v, k)$：
1. 前 `dp[v]` 秒：在 v 的子树内游荡（按照欧拉序遍历）
2. 然后向上走到父节点
3. 继续向上...

如果 `k <= dp[v]`：Bob 还在子树内，答案是欧拉序上 `pos[v] + k` 位置的节点

如果 `k > dp[v]`：Bob 已经走出子树，需要向上走到某个祖先，然后在那个位置继续

---

## 六、总结

本题是 E 题的扩展，引入了查询操作，需要：
1. 理解 Bob 的运动轨迹与DFS的关系
2. 利用倍增法快速定位祖先
3. 利用欧拉序快速回答子树内的查询

**核心思想**：倍增 + 欧拉序 + 树形DP
