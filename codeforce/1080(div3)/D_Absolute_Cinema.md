# Codeforces Round 1080 (Div. 3) - Problem D: Absolute Cinema

## 题目描述

给定一个隐藏的整数序列 $a_1, a_2, \dots, a_n$，其中 $|a_i| \le 1000$。

定义函数：
$$f(x) = \sum_{i=1}^{n} a_i \cdot |i - x|$$

现在给定 $f(1), f(2), \dots, f(n)$ 的值，要求还原原始序列 $a_1, a_2, \dots, a_n$。

保证序列能唯一确定。

### 输入格式
- 第一行：整数 `t` $(t \le 10^4)$，测试用例数量
- 每个测试用例：
  - 第一行：整数 `n` $(2 \le n \le 3 \cdot 10^5)$
  - 第二行：`n` 个整数 $f(1), f(2), \dots, f(n)$ $(-10^{14} \le f(i) \le 10^{14})$

- 所有测试用例的 $n$ 之和不超过 $3 \cdot 10^5$

### 输出格式
- 对每个测试用例，输出还原的序列 $a_1, a_2, \dots, a_n$

### 示例
```
输入：
3
2
10 20
3
15 10 15
4
30 20 20 30

输出：
10 10
5 5 5
10 5 5 10
```

---

## 一、题目解析

### 题意理解
我们有一个隐藏的序列 `a`，已知的是函数 `f` 在整数点 1 到 n 处的值。

函数 `f(x)` 是序列 `a` 的加权绝对值和，权重取决于位置与 `x` 的距离。

### 核心问题
**关键观察**：利用差分来消除绝对值。

计算相邻 `f` 值的差：
$$f(x+1) - f(x) = \sum_{i=1}^{x} 2a_i - \sum_{i=1}^{n} a_i$$

进一步差分：
$$[f(x+2) - f(x+1)] - [f(x+1) - f(x)] = 2a_{x+1}$$

### 解题思路

1. **计算一阶差分**：$d[i] = f[i+1] - f[i]$，其中 $i = 1, \dots, n-1$

2. **计算二阶差分**：$a[i] = (d[i] - d[i-1]) / 2$，其中 $i = 2, \dots, n-1$

3. **求解边界**：
   - $a[1]$ 和 $a[n]$ 需要通过其他方式求解
   - 利用总和关系：$\sum a_i \cdot (n-i) = f[n]$ 和 $\sum a_i \cdot (i-1) = f[1]$

---

## 二、知识点归类

| 类别 | 内容 |
|------|------|
| **主要算法** | 数学推导、差分 |
| **数据结构** | 数组 |
| **编程技巧** | 前缀和、差分数组 |
| **难度等级** | ⭐⭐⭐ 中等 |

---

## 三、关键提示点

### 易错点提醒
- ❌ 忘记除以2时的整数除法问题
- ❌ 边界条件 $a[1]$ 和 $a[n]$ 的处理
- ❌ 差分数组的下标越界

### 边界条件
- `n = 2`：需要特殊处理，因为没有中间元素
- 差分公式只适用于 $i = 2, \dots, n-1$

### 优化思路
- 预处理前缀和可以加速 $a[1]$ 和 $a[n]$ 的计算

### 常见陷阱
- 误以为需要矩阵求逆或高斯消元
- 没有利用差分的性质简化问题

---

## 四、代码解析（详细中文注释）

```cpp
#include <bits/stdc++.h>
using namespace std;

const int N = 300000;      // 最大数据范围

int n;                     // 序列长度
long long f[N + 10];       // f[i]: 输入的函数值
long long d[N + 10];       // d[i]: 一阶差分 f[i+1] - f[i]
long long a[N + 10];       // a[i]: 还原的原始序列

void work() {
    cin >> n;
    
    // 读取f值
    for (int i = 1; i <= n; ++i) {
        cin >> f[i];
    }
    
    // 计算一阶差分：d[i] = f[i+1] - f[i]
    // d[i] 对应 i = 1, 2, ..., n-1
    for (int i = 1; i < n; ++i) {
        d[i] = f[i + 1] - f[i];
    }
    
    // 计算中间元素 a[2] 到 a[n-1]
    // 公式：a[i] = (d[i] - d[i-1]) / 2
    for (int i = 2; i < n; ++i) {
        a[i] = (d[i] - d[i - 1]) / 2;
    }
    
    // 计算边界值 a[1] 和 a[n]
    // 利用：f[n] = sum(a[i] * (n - i))
    // 和：f[1] = sum(a[i] * (i - 1))
    a[1] = f[n];
    a[n] = f[1];
    
    // 消去已知中间项的贡献
    for (int i = 2; i < n; ++i) {
        // 从f[n]的方程中减去 a[i] * (n - i)
        a[1] -= a[i] * abs(n - i);
        // 从f[1]的方程中减去 a[i] * (i - 1)
        a[n] -= a[i] * abs(1 - i);
    }
    
    // 除以系数得到最终值
    // 因为 f[n] = a[1]*(n-1) + ...，所以a[1] = f[n] / (n-1) 在消去其他项后
    a[1] /= n - 1;
    a[n] /= n - 1;
    
    // 输出结果
    for (int i = 1; i <= n; ++i) {
        cout << a[i] << ' ';
    }
    cout << '\n';
}

int main() {
    int T;              // 测试用例数量
    cin >> T;
    while (T--) work();
    return 0;
}
```

### 变量含义
| 变量 | 含义 |
|------|------|
| `n` | 序列长度 |
| `f[i]` | 输入的函数值 f(i) |
| `d[i]` | 一阶差分 d[i] = f[i+1] - f[i] |
| `a[i]` | 还原的原始序列 |

### 算法步骤
1. 读取函数值 `f[1..n]`
2. 计算一阶差分 `d[i] = f[i+1] - f[i]`
3. 计算中间元素：`a[i] = (d[i] - d[i-1]) / 2`，其中 $i = 2, \dots, n-1$
4. 初始化 `a[1] = f[n]`，`a[n] = f[1]`
5. 消去中间项对边界方程的贡献
6. 除以 `(n-1)` 得到边界值
7. 输出序列

### 关键操作的作用
- `(d[i] - d[i-1]) / 2`：二阶差分恢复原始值
- `a[1] -= a[i] * abs(n - i)`：消去已知项对总和方程的贡献

### 时间复杂度分析
- **时间复杂度**：$O(n)$
  - 需要遍历数组几次
- **空间复杂度**：$O(n)$
  - 需要存储f、d、a数组

---

## 五、数学推导详解

### 一阶差分推导
```
f(x) = sum_{i=1}^n a_i * |i - x|

f(x+1) - f(x) 
= sum_{i=1}^x a_i * [(x+1-i) - (x-i)] + sum_{i=x+1}^n a_i * [(i-x-1) - (i-x)]
= sum_{i=1}^x a_i * 1 + sum_{i=x+1}^n a_i * (-1)
= 2 * sum_{i=1}^x a_i - sum_{i=1}^n a_i
```

### 二阶差分推导
```
d[x] = f(x+1) - f(x) = 2 * S[x] - S[n]  （其中S[x]是a的前缀和）

d[x] - d[x-1] = 2 * S[x] - 2 * S[x-1] = 2 * a[x]

所以：a[x] = (d[x] - d[x-1]) / 2
```

### 边界值推导
```
f[1] = sum_{i=1}^n a_i * (i-1) = a_1*0 + a_2*1 + ... + a_n*(n-1)
f[n] = sum_{i=1}^n a_i * (n-i) = a_1*(n-1) + a_2*(n-2) + ... + a_n*0

已知a[2..n-1]后，可以求出：
a[1]*(n-1) = f[n] - sum_{i=2}^{n-1} a_i*(n-i)
a[n]*(n-1) = f[1] - sum_{i=2}^{n-1} a_i*(i-1)
```

---

## 六、总结

本题是一道经典的**逆问题求解**，关键在于：
1. 理解绝对值函数的差分性质
2. 通过两次差分消除绝对值的影响
3. 利用线性方程组求解边界值

**核心思想**：差分技巧 + 线性代数
