# Codeforces Round 1080 (Div. 3) - Problem C: Dice Roll Sequence

## 题目描述

给定一个由整数 1~6 组成的序列 `a`，你可以修改序列中的任意元素。目标是将序列变为"骰子掷出序列"。

**骰子掷出序列的定义**：相邻元素代表骰子相邻的面。骰子面 `x` 的对面是 `7-x`（即1对6，2对5，3对4），对面不相邻。

求最少需要多少次修改操作。

### 输入格式
- 第一行：整数 `t` $(1 \le t \le 10^4)$，测试用例数量
- 每个测试用例：
  - 第一行：整数 `n` $(1 \le n \le 3 \cdot 10^5)$，序列长度
  - 第二行：`n` 个整数 $a_i$ $(1 \le a_i \le 6)$

- 所有测试用例的 $n$ 之和不超过 $3 \cdot 10^5$

### 输出格式
- 对每个测试用例，输出最少修改次数

### 示例
```
输入：
3
5
1 2 3 4 5
4
1 1 1 1
3
1 6 2

输出：
0
2
1
```

**解释**：
- 例1：序列已经是合法的骰子序列
- 例2：可以将序列改为 1 2 1 2 或 1 6 1 6 等，需要2次修改
- 例3：1和6是对面，不能相邻。修改6为3，得到1 3 2，是合法序列

---

## 一、题目解析

### 题意理解
骰子的六个面有如下相邻关系：
- 1 的相邻面：2, 3, 4, 5（对面是6）
- 2 的相邻面：1, 3, 5, 6（对面是5）
- 3 的相邻面：1, 2, 4, 6（对面是4）
- 4 的相邻面：1, 3, 5, 6（对面是3）
- 5 的相邻面：1, 2, 4, 6（对面是2）
- 6 的相邻面：2, 3, 4, 5（对面是1）

两个面相邻当且仅当它们的和不等于7且它们不相等。

### 核心问题
我们需要找到一个骰子序列，使得与原序列的汉明距离最小（即修改位置最少）。

### 解题思路

#### 方法一：动态规划（DP）
设 `dp[i][j]` 表示将前 `i` 个元素变为合法序列，且第 `i` 个元素为 `j` 的最小修改次数。

状态转移：
```
dp[i][j] = min(dp[i-1][k]) + (a[i] != j)
          其中 k 满足：k != j 且 k + j != 7
```

初始状态：`dp[0][j] = 0`（空序列不需要修改）

#### 方法二：贪心（适用于特定情况）
由于只有6个面，可以证明某些情况下贪心也是正确的。但DP是最稳妥的方法。

---

## 二、知识点归类

| 类别 | 内容 |
|------|------|
| **主要算法** | 动态规划（DP） |
| **数据结构** | 二维数组 |
| **编程技巧** | 状态压缩、预处理转移 |
| **难度等级** | ⭐⭐⭐ 中等 |

---

## 三、关键提示点

### 易错点提醒
- ❌ 错误理解相邻关系（忘记和不等于7的条件）
- ❌ 忘记初始化DP数组为无穷大
- ❌ 混淆 `i` 是位置还是值

### 边界条件
- `n = 1`：任何单个数字都是合法的，答案为0
- 所有数字都相同：需要修改一半左右

### 优化思路
- 由于只有6个状态，可以用位运算优化
- 预处理每个数字的合法前驱集合

### 常见陷阱
- 认为1和6是相邻的（其实是对面）
- 认为相同数字可以相邻（其实不行）

---

## 四、代码解析（详细中文注释）

```cpp
#include <bits/stdc++.h>
using namespace std;

const int N = 300000;      // 最大序列长度
const int INF = 0x3f3f3f3f; // 无穷大（约为1e9）

int n;                     // 序列长度
int a[N + 10];             // 原序列
int dp[N + 10][7];         // dp[i][j]: 前i个元素，第i个为j的最小修改次数

void work() {
    cin >> n;
    
    // 读取序列
    for (int i = 1; i <= n; ++i) {
        cin >> a[i];
    }
    
    // 初始化dp[0]：空序列代价为0
    for (int j = 1; j <= 6; ++j) {
        dp[0][j] = 0;
    }
    
    // DP过程
    for (int i = 1; i <= n; ++i) {
        // 将dp[i]初始化为无穷大
        memset(dp[i], 0x3f, sizeof(dp[i]));
        
        // 枚举当前位置i放置的数字x（1到6）
        for (int x = 1; x <= 6; ++x) {
            // 枚举前一个位置i-1放置的数字y
            for (int y = 1; y <= 6; ++y) {
                // 检查合法性：x和y不能相等，也不能对面（和为7）
                if (x + y == 7 || x == y) continue;
                
                // 状态转移：从dp[i-1][y]转移到dp[i][x]
                // 代价增加：(a[i] == x ? 0 : 1)，即如果原数字就是x则无需修改
                dp[i][x] = min(dp[i][x], dp[i - 1][y] + (a[i] == x ? 0 : 1));
            }
        }
    }
    
    // 答案是min(dp[n][1..6])，即所有可能的结尾的最小值
    int ans = INF;
    for (int i = 1; i <= 6; ++i) {
        ans = min(ans, dp[n][i]);
    }
    
    cout << ans << '\n';
}

int main() {
    int T;              // 测试用例数量
    cin >> T;
    while (T--) work();
    return 0;
}
```

### 变量含义
| 变量 | 含义 |
|------|------|
| `n` | 序列长度 |
| `a[i]` | 原序列第i个元素 |
| `dp[i][j]` | 前i个元素，第i个改为j的最小修改次数 |
| `INF` | 无穷大标记 |
| `x` | 当前枚举的数值（1-6） |
| `y` | 前一个位置枚举的数值（1-6） |

### 算法步骤
1. 读取序列
2. 初始化 `dp[0][j] = 0`
3. 对于每个位置 `i`：
   - 初始化 `dp[i]` 为无穷大
   - 枚举当前值 `x`（1-6）
   - 枚举前一个值 `y`（1-6）
   - 如果 `x` 和 `y` 合法（不相等且不对面），更新 `dp[i][x]`
4. 答案取 `min(dp[n][1..6])`

### 关键操作的作用
- `memset(dp[i], 0x3f, sizeof(dp[i]))`：将数组初始化为一个很大的数
- `x + y == 7`：判断两个面是否对面
- `(a[i] == x ? 0 : 1)`：计算修改代价

### 时间复杂度分析
- **时间复杂度**：$O(36 \times n)$ = $O(n)$
  - 对每个位置，枚举6×6=36种转移
- **空间复杂度**：$O(6 \times n)$ = $O(n)$
  - 需要二维DP数组

---

## 五、优化版本（空间优化）

```cpp
#include <bits/stdc++.h>
using namespace std;

const int INF = 1e9;

void solve() {
    int n;
    cin >> n;
    vector<int> a(n);
    for (int &x : a) cin >> x;
    
    // 只保留两层状态，空间优化为O(1)
    vector<int> prev(7, 0), curr(7, INF);
    
    for (int i = 0; i < n; i++) {
        fill(curr.begin(), curr.end(), INF);
        for (int x = 1; x <= 6; x++) {
            for (int y = 1; y <= 6; y++) {
                if (x != y && x + y != 7) {
                    curr[x] = min(curr[x], prev[y] + (a[i] != x));
                }
            }
        }
        swap(prev, curr);
    }
    
    cout << *min_element(prev.begin() + 1, prev.end()) << '\n';
}

int main() {
    int T;
    cin >> T;
    while (T--) solve();
    return 0;
}
```

---

## 六、总结

本题是典型的**状态受限的序列DP**问题：
1. 状态空间很小（只有6个可能值）
2. 转移有约束（相邻限制）
3. 目标是最大化保留原序列中的元素

**核心思想**：状态有限性 + 动态规划

---

## 七、拓展思考

如果骰子有 `m` 个面，该如何解决？
- 时间复杂度变为 $O(m^2 \times n)$
- 如果 `m` 很大，可能需要其他方法（如图论中的最短路径）
