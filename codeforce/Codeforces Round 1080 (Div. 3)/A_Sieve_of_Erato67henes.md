# Codeforces Round 1080 (Div. 3) - Problem A: Sieve of Erato67henes

## 题目描述

给定 `n` 个正整数 $a_1, a_2, \dots, a_n$，判断是否可以从这些数中选择任意数量（至少一个）的元素，使它们的乘积恰好为 **67**。

### 输入格式
- 第一行：整数 `t` $(1 \le t \le 10^4)$，表示测试用例数量
- 每个测试用例：
  - 第一行：整数 `n` $(1 \le n \le 5)$，表示数字个数
  - 第二行：`n` 个整数 $a_i$ $(1 \le a_i \le 67)$

### 输出格式
- 对于每个测试用例，输出 "YES" 如果可以选出若干数乘积为67，否则输出 "NO"

### 示例
```
输入：
3
2
67 1
3
2 3 5
1
67

输出：
YES
NO
YES
```

---

## 一、题目解析

### 题意理解
我们需要从给定的一组数字中，选出至少一个数字（可以选全部，也可以只选一部分），使得这些被选中的数字的乘积恰好等于67。

### 核心问题
- 67 是一个**质数**
- 质数的因数只有 1 和它本身
- 要得到乘积为 67，必须选中数字 67 本身（因为其他数的乘积不可能等于67）

### 解题思路
1. 由于 67 是质数，它的正因子只有 1 和 67
2. 如果数组中包含 67，我们可以直接选它，乘积就是 67
3. 如果数组中不包含 67，那么无论如何组合，乘积都不可能等于 67（因为没有因子 67）
4. 因此问题简化为：**检查数组中是否存在数字 67**

---

## 二、知识点归类

| 类别 | 内容 |
|------|------|
| **主要算法** | 简单判断、质数性质 |
| **数据结构** | 数组（基本存储） |
| **编程技巧** | 质数因子分析、问题简化 |
| **难度等级** | ⭐ 简单 |

---

## 三、关键提示点

### 易错点提醒
- ❌ 误以为需要枚举所有子集
- ❌ 忽略了 67 是质数这一关键性质
- ❌ 忘记题目要求至少选择一个元素

### 边界条件
- `n = 1` 的情况：检查这一个数是否为 67
- 数组中可能有多个 67
- 所有数都是 1 的情况

### 优化思路
直接 $O(n)$ 扫描即可，无需复杂算法

### 常见陷阱
- 误以为需要 DFS/BFS 枚举子集（$2^n$ 复杂度）
- 没有利用质数的性质简化问题

---

## 四、代码解析（详细中文注释）

```cpp
#include <bits/stdc++.h>
using namespace std;

// 处理单个测试用例的函数
void work() {
    int n;              // n: 数字个数
    cin >> n; 
    int ans = 0;        // ans: 标记是否找到67，0表示未找到，1表示找到
    
    // 遍历 n 个数字
    for (int i = 1; i <= n; ++i) {
        int u;          // u: 当前输入的数字
        cin >> u; 
        // 如果当前数字等于67，设置标记为1
        if (u == 67) ans = 1;
    }
    
    // 根据标记输出结果
    // 使用三元运算符: ans为1输出YES，否则输出NO
    cout << (ans ? "YES" : "NO") << '\n';
}

int main() {
    int T;              // T: 测试用例数量
    cin >> T;
    // 循环处理每个测试用例
    while (T--) work();
    return 0;
}
```

### 变量含义
| 变量 | 含义 |
|------|------|
| `n` | 当前测试用例的数字个数 |
| `u` | 当前读入的数字 |
| `ans` | 标记变量，记录是否找到67 |
| `T` | 测试用例总数 |

### 算法步骤
1. 读取测试用例数量 T
2. 对每个测试用例：
   - 读取数字个数 n
   - 初始化标记 ans = 0
   - 循环 n 次读取数字，如果等于67则设置 ans = 1
   - 输出结果

### 关键操作的作用
- `ans ? "YES" : "NO"`：三元运算符简化输出逻辑
- `while (T--)`：简洁地循环处理所有测试用例

### 时间复杂度分析
- **时间复杂度**：$O(T \times n)$，其中 $n \le 5$，所以实际上是 $O(T)$
- **空间复杂度**：$O(1)$，只使用了常数额外空间

---

## 五、类似题目推荐
- Codeforces 1749A - Cowardly Rooks
- Codeforces 1760A - Medium Number

---

## 六、总结

本题是一个简单的观察题，关键在于：
1. 识别 67 是质数
2. 理解质数的性质：只有包含质数本身才能得到该质数作为乘积
3. 将问题简化为简单的存在性判断

**核心思想**：数学性质分析 + 问题简化
