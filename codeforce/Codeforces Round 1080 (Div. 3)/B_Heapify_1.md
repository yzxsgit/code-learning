# Codeforces Round 1080 (Div. 3) - Problem B: Heapify 1

## 题目描述

给定一个长度为 `n` 的排列 `a`。可以重复执行以下操作：
- 选择索引 `i` $(1 \le i \le n/2)$，交换 $a_i$ 和 $a_{2i}$

判断序列 `a` 是否能通过这些操作排序成升序。

### 输入格式
- 第一行：整数 `t` $(1 \le t \le 10^4)$，测试用例数量
- 每个测试用例：
  - 第一行：整数 `n` $(1 \le n \le 2 \cdot 10^5)$
  - 第二行：`n` 个整数，表示排列 `a`

- 所有测试用例的 $n$ 之和不超过 $2 \cdot 10^5$

### 输出格式
- 对每个测试用例，输出 "YES" 如果可以排序，否则输出 "NO"

### 示例
```
输入：
3
5
1 2 3 4 5
5
5 4 3 2 1
5
2 1 3 4 5

输出：
YES
NO
NO
```

---

## 一、题目解析

### 题意理解
我们有一个排列，只能通过特定的交换操作来改变元素位置：
- 位置 `i` 的元素可以和位置 `2*i` 的元素交换

可以重复进行这样的交换。问最终能否将数组排成升序。

### 核心问题
**关键观察**：位置 `i` 只能和位置 `2i, 4i, 8i, ...` 以及 `i/2, i/4, ...` 上的元素交换。

这意味着：
- 将所有能互相到达的位置分成若干**连通块**
- 每个连通块内的元素只能在块内移动
- 要使得数组有序，每个连通块内的元素集合必须恰好等于该连通块对应位置的值集合

### 解题思路

#### 方法一：模拟交换过程（官方解法）
1. 建立值到位置的映射 `pos[value] = index`
2. 对于每个值 `i`（从1到n），将其移动到正确位置：
   - 当前值 `i` 在位置 `pos[i]`
   - 需要将其移动到位置 `i`
   - 只能通过不断除以2的方式移动（即和 `pos[i]/2` 交换）
   - 如果 `pos[i]` 无法通过不断除以2变成 `i`，则无法排序
   - 如果 `pos[i]` 变成奇数但还不等于 `i`，也无法排序

#### 方法二：分组判断（更简洁）
1. 对于每个位置 `i`，找到其所属的"家族"：所有形如 `i * 2^k` 或 `i / 2^k` 的位置
2. 对于升序数组，位置 `i` 应该放值 `i`
3. 检查每个家族中，原数组的值集合是否等于位置集合

---

## 二、知识点归类

| 类别 | 内容 |
|------|------|
| **主要算法** | 模拟、置换、连通块分析 |
| **数据结构** | 数组、映射 |
| **编程技巧** | 位运算分析、贪心移动 |
| **难度等级** | ⭐⭐ 简单-中等 |

---

## 三、关键提示点

### 易错点提醒
- ❌ 误以为可以进行任意相邻交换
- ❌ 没有正确处理奇数位置的情况
- ❌ 忽略了 `pos[i]` 必须在除以2的过程中保持为整数

### 边界条件
- `n = 1`：已经有序
- 位置为偶数时需要能一直除以2直到正确位置
- 位置为奇数且不等于目标位置时，无法移动

### 优化思路
核心观察：位置 `i` 能到达的所有位置，其二进制表示中去掉末尾的0后相同。
- 例如：位置 3(11₂), 6(110₂), 12(1100₂) 可以互相到达
- 位置 1(1₂), 2(10₂), 4(100₂) 可以互相到达

所以可以将所有位置按 `i / (2^k)`（即去掉所有末尾0）的值分组。

### 常见陷阱
- 试图使用冒泡排序的思维，复杂化问题
- 没有注意到 `pos[i]` 变成奇数时的特殊情况

---

## 四、代码解析（详细中文注释）

```cpp
#include <bits/stdc++.h>
using namespace std;

const int N = 200000;  // 最大数据范围

int n;                 // 当前测试用例的数组长度
int a[N + 10];         // a[i]: 位置i上的值
int pos[N + 10];       // pos[v]: 值v当前所在的位置

// 交换位置u和位置v上的元素，同时更新映射关系
void Swap(int u, int v) {
    // 交换数组中的值
    swap(a[u], a[v]); 
    // 更新值到位置的映射
    swap(pos[a[u]], pos[a[v]]);
}

// 处理单个测试用例
void work() {
    cin >> n;
    
    // 读取数组并建立值到位置的映射
    for (int i = 1; i <= n; ++i) {
        cin >> a[i];      // 读取位置i上的值
        pos[a[i]] = i;    // 记录值a[i]在位置i
    }
    
    // 尝试将每个值i移动到位置i
    for (int i = 1; i <= n; ++i) {
        // 当值i的位置大于i时，需要向上移动（和父节点交换）
        while (pos[i] > i) {
            // 如果当前位置是奇数，无法继续除以2
            // 因为只能和pos[i]/2交换，奇数除以2不是整数
            if (pos[i] & 1) {
                cout << "NO" << '\n'; 
                return;
            }
            // 和父节点交换（pos[i]/2 和 pos[i] 交换）
            Swap(pos[i] >> 1, pos[i]);
        }
        
        // 如果值i的位置小于i，说明无法移动到正确位置
        // 因为只能向上移动（除以2），不能向下移动
        if (pos[i] < i) {
            cout << "NO" << '\n'; 
            return;
        }
    }
    
    // 所有值都移动到正确位置
    cout << "YES" << '\n';
}

int main() {
    int T;              // 测试用例数量
    cin >> T;
    while (T--) work();
    return 0;
}
```

### 变量含义
| 变量 | 含义 |
|------|------|
| `n` | 数组长度 |
| `a[i]` | 位置i上当前的值 |
| `pos[v]` | 值v当前所在的位置 |
| `T` | 测试用例数量 |

### 算法步骤
1. 读取数组
2. 建立 `pos` 映射：值 → 位置
3. 对于每个值 `i` 从 1 到 n：
   - 如果 `pos[i] > i`：需要通过不断除以2来上移
   - 如果中途遇到奇数（无法整除），输出NO
   - 如果 `pos[i] < i`：无法下移，输出NO
4. 所有值都能到达正确位置，输出YES

### 关键操作的作用
- `pos[i] & 1`：位运算判断奇偶，奇数时最低位为1
- `pos[i] >> 1`：右移一位，等价于除以2
- `Swap` 函数：同时更新数组和映射关系

### 时间复杂度分析
- **时间复杂度**：$O(n \log n)$
  - 每个元素最多移动 $\log n$ 次（每次位置至少减半）
- **空间复杂度**：$O(n)$
  - 需要存储数组和位置映射

---

## 五、另一种简洁解法

```cpp
#include <bits/stdc++.h>
using namespace std;

void solve() {
    int n;
    cin >> n;
    bool ok = true;
    
    for (int i = 1; i <= n && ok; i++) {
        int x;
        cin >> x;
        
        // 关键：x和i必须能互相到达
        // 即 x / (2^k1) == i / (2^k2) 对于某些k1, k2
        // 等价于：去掉末尾所有0后相等
        
        // 方法：不断除以2直到奇数
        int a = x, b = i;
        while (a % 2 == 0) a /= 2;
        while (b % 2 == 0) b /= 2;
        
        // 如果去掉所有因子2后不相等，说明不在同一组
        if (a != b) ok = false;
    }
    
    cout << (ok ? "YES" : "NO") << '\n';
}

int main() {
    int T;
    cin >> T;
    while (T--) solve();
    return 0;
}
```

---

## 六、总结

本题的关键在于理解交换操作形成的**连通性结构**：
1. 位置形成树状结构（类似二叉堆）
2. 每个位置只能和其祖先/后代交换
3. 要排序成功，每个连通块内的值集合必须匹配

**核心思想**：置换群的连通块分析 + 贪心移动策略
